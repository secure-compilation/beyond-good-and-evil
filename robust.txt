
* Robust compilation

Goal: we want a (probably) weaker notion of secure compilation that
only captures the integrity aspect of it, and leaves out the
confidentiality aspect.

* Gordon-Jeffrey:

P is robustly safe iff
forall C. C[P] is safe
- syntactic restriction on contexts
  - where only P can break safety 
  - C is assertion free -> C cannot break safety

For them it could be that robust compilation is as hard to get as
fully abstract one.

They add syntactic assert statements, that prove certain (robust)
safety properties of the program.

* Our instance from CSF submission

fully defined =? robustly defined
- not simple to prevent the context 
  + semantic dual restriction on contexts

* Patrignani

For them robust compilation seems much easier to obtain than full
abstraction, since they could for instance allow pointers to be passed
out without being turned into handlers. Distinguishing pointers
(e.g. comparing them for equality) would probably not cause problems
for robust compilation. At the same time they still need a way to
preserve the integrity of pointers ... which they also achieve with
handlers. Instead they could just cryptographically sign/MAC pointers
or keep a big hash table with all the valid pointers that escape.

* Micro-policies

Robust compilation would at least save us from having to hide sizes of
things and we can allow side- and covert-channels. Hopefully we can
prove full abstraction without side-channels and robust compilation
with them.

* Q: How does one define robust safety/compilation in these other settings?

There are probably both intrinsic (asserts) and extrinsic (traces) ways to do it.

* Q: Does robust compilation allow refinement of non-determinism?

What exactly is it about FA that prevents refinement of non-determinism?
Would dropping the boring FA direction help with this, for instance?

* References

Original robust safety work:
http://ect.bell-labs.com/who/ajeffrey/papers/jcs03.pdf:
- "We are mainly concerned not just with safety, but with safety in
  the presence of an arbitrary hostile opponent, which we call robust
  safety. (This use of "robust" to describe a property invariant under
  composition with an arbitrary environment follows Grumberg and
  Long [20])"

[20] O. Grumberg and D.E. Long. Model checking and modular verification. ACM
Transactions on Programming Languages and Systems, 16(3):843â€“871, 1994.
http://www.cse.usf.edu/~zheng/lib/verification/compositional/grumberg-modular94.pdf

David Swasey and Derek Dreyer ongoing work on robust safety in Iris
(should ask them for a copy after ICFP)
http://www.mpi-sws.org/~swasey/

Quantification of Integrity. Mathematical Structures in Computer
Science, 25(2):207-258, 2015. Michael R. Clarkson, Fred B. Schneider.
https://www.cs.cornell.edu/~clarkson/papers/clarkson_integrity_journal.pdf
