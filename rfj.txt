================================================================================
| Syntax
================================================================================

C - class name -- mapped to class declarations L (CT)
f - field name
m - method name
o - object names -- mapped to object declarations O (OT)

L ::=                        class declaration
  class {C1 f1, ..., Cn fn;    field declarations
            M1, ...,    Mm}    method declarations

O ::=                        object declaration
  obj C {o1, ..., on}

M ::=                        method declaration
  Cr m (Ca)                    result and arg type
    { e }                      method body

x ::=
  | this
  | arg

e ::=                        expressions
  | x                          variables
  | o                          object reference
  | e.f                        field selection
  | e.m(e)                     method call
  | e == e ? e : e             object identity test

================================================================================
| Operational semantics
================================================================================

OT(o) = obj C {o1, ..., on}
CT(C) = class {C1 f1, ..., Cn fn; ...}
i in [1,n]
--------------------------------------
o.fi --> oi


OT(o) = obj C {o1, ..., on}
CT(C) = class {...; M1, ..., Mm }
Mi = Cr mi(Ca) { e }
i in [1,m]
--------------------------------
o.mi(oa) --> e[oa/arg][o/this]

---------------------
o == o ? e : e' --> e

o <> o'
-----------------------
o == o' ? e : e' --> e'

e1 --> e1'
------------------------
e1.mi(e2) --> e1'.mi(e2)


e --> e'
--------------------
o.mi(e) --> o.mi(e')

e1 --> e1'
------------------------------------------
e1 == e2 ? e3 : e4 --> e1' == e2 ? e3 : e4

e2 --> e2'
------------------------------------------
o == e2 ? e3 : e4 --> o == e2' ? e3 : e4


================================================================================
| Type system
================================================================================

Object declaration typing:

classof(o) = C   if OT(o) = obj C {...}

CT(C) = class {C1 f1, ..., Cn fn; ...}
forall i. classof(oi) = Ci
--------------------------------------
|- obj C {o1, ..., on} ok

--------------------------------------------------------------------------------

Expression typing:

G ::= {} | {this:Ct, arg:Ca}

G |- x : G(x)

G |- o : classof(o)

G |- e : C
G(this) = C                                     ensure privacy of fields
CT(C) = class {C1 f1, ..., Cn fn; ...}
i in [1,n]
--------------------------------------
G |- e.fi : Ci

G |- e : C
CT(C) = class {...; M1, ..., Mm}
i in [1,m]
Mi = Cr mi(Ca) { ... }
G |- ea : Ca
--------------------------------
G |- e.m(ea) : Cr

G |- e1 : C'
G |- e2 : C'
G |- e3 : C
G |- e4 : C
---------------------------
G |- (e1 == e2 ? e3 : e4) : C

--------------------------------------------------------------------------------

Method typing:

CT(C) = class {...; M1, ..., Mm}
i in [1,m]
Mi = Cr mi(Ca) { e }
{this:C, arg:Ca} |- e : Cr
--------------------------
C |- Cr mi(Ca) { e } ok

--------------------------------------------------------------------------------

Class typing:

CT(C) = class {C1 f1, ..., Cn fn; M1, ..., Mm}
forall i. C |- Mi ok
----------------------------------------------
|- C ok

================================================================================
| Encodings
================================================================================

Tuples:

For each tuple type T=(C1, ..., Cn)

class Unit {}

class Tuple_T {C1 f_1, ..., Cn f_n,
               C1 get_1(Unit) { this.f_1 },
               ...
               Cn get_n(Unit) { this.f_n },
}

--------------------------------------------------------------------------------

Booleans:

class Bool {}

obj true : Bool {}
obj false : Bool {}

If then else via identity test (== operator).

================================================================================
| "Really" abstract machine
================================================================================

Syntax:

 i ::= this | arg                   immutable registers
 r ::= res | aux                    mutable registers
 c ::= n                            class index (where n is a natural number)
 o ::= n                            object index (where n is a natural number)
 f ::= n                            field index (where n is a natural number)
 m ::= n                            method index (where n is a natural number)

 instr ::=
 | Nop
 | Push (i | r)                     push a register's value on top of the stack
 | Pop r                            pop the value on top of the stack to a register
 | Ref o r                          put an object reference into a register
 | Copy (i | r) r                   copy register content
 | Select (i | r) f r               field selection
 | Call (i | r) m (i | r) r         method call
 | Beq (i | r) (i | r) n            equality test with forward jump
                                    (skip n instructions if equal)

 code ::= [] | instr :: code

 methods ::= [] | code :: methods
 fields ::= [] | o :: fields

 class ::= methods
 classes ::= [] | class :: classes

 object ::= fields
 objects ::= [] | object :: objects

 program ::= (classes, objects, code)

 stack ::= [] | o :: stack
 stacks ::= [] | stack :: stacks

 state ::= (program, stacks)

--------------------------------------------------------------------------------

Reduction:

  ((classes, objects, Nop :: code), stacks) -> ((classes, objects, code), stacks)

--------------------------------------------------------------------------------

Compilation:

c_expr(this) = Copy this res
  (G(this) is defined in this case)

c_expr(arg) = Copy arg res
  (G(arg) is defined in this case)

c_expr(o) = Ref o res

c_expr(e.f) =
     c_expr(e);
     Select res f res

c_expr(e.m(e')) =
     c_expr(e);
     Push res;
     c_expr(e');
     Pop aux;
     Call aux m res res

c_expr(e1 == e2 ? e3 : e4) =
     c_expr(e1);
     Push res;
     c_expr(e1);
     Pop aux;
     Beq res aux EQ;                 note: these are indeed relative forward jumps (so this works)
     c_expr(e4);
     Beq res res END;                <--- a way to encode unconditional forward jump
EQ:  c_expr(e3);
END: Nop


================================================================================
| Compilation scheme
================================================================================

Define two tables:

  CIT (Class Index Table): maps classes to a number
  OIT (Object Index Table): maps objects to a number

And for each class:

  fieldoffset(C, f)
  methodoffset(C, m)

--------------------------------------------------------------------------------

Monitor services in the abstract machine:

* the idea: one stack per component ;
* two design choices:
    - a global stack handled by the monitor ;
    - or each stack located within the compartment of the component ;
* here: abstract machine, so we can manage them in the state for the moment.

/!\ need to forbid Jump-ing between compartements (e.g. for calling monitor services)
    --> only Jal
    (otherwise, we don't know who did the call, r_a may have been maliciously set by the attacker
     e.g. the stack of a component could be compromised by calling PUSH)

reg[r_arg1] = w
reg[r_a] = pc'
pc' in C_i
pc' - 1 in C_i                                   forbid jumps between distinct compartments
-----------------------------------------------------------------------------------------------
(mem, reg, push_addr, s_1, ..., s_i, ..., s_n) -> (mem, reg, pc', s_1, ..., w :: s_i, ..., s_n)

pc' in C_i
pc' - 1 in C_i                                   forbid jumps between distinct compartments
reg' = reg[r_ret <- w]
----------------------------------------------------------------------------------------------
(mem, reg, pop_addr, s_1, ..., w :: s_i, ..., s_n) -> (mem, reg', pc', s1, ..., s_i, ..., s_n)

mem[pc] = i
decode i = CALL rc rm ro rp
reg[rc] = c
reg[rm] = m
reg[ro] = o
reg[rp] = p

----------------------------
(mem, reg, pc, s) -> (mem, reg', pc', s)

mem[pc] = i
decode i = 
??
---------------
??

mem[pc] = i
decode[i] = Get ro rd
??
-----------------------
??

--------------------------------------------------------------------------------

Compilation of well-typed expressions:
  Variant #1: - doing everything via system calls
              - protection via compartmentalization micro-policy

Fix four distinct registers: r_this, r_arg, r_arg1, r_arg2, r_arg3, r_res (=r_ret), r_aux.

G = {this:Ct, arg:Ca} when compiling a method body.
G = {} when compiling the main expression.

Properties of c_expr:
- invariant: r_arg and r_this are preserved
            (they can change internally, but are restored at the end)
- can overwrite all other registers
- writes result to r_res
- finishes with same stack as it was called (restores the original stack)

c_expr(this) = Mov r_this r_res
  (G(this) is defined in this case)

c_expr(arg) = Mov r_arg r_res
  (G(arg) is defined in this case)

c_expr(o) = Const o r_res

c_expr(e.f) =
    c_expr(e);
    Mov r_res r_arg1;
    Cons i_f r_arg2;
    Jal SELECT
  if G |- e : C (deterministic)
  and i_f = fieldoffset(C, f)

c_expr(e.m(e')) =
    c_expr(e);
    Jal PUSH r_res;
    c_expr(e');
    Pop r_arg1;
    Mov r_res r_arg2;
    Const i_m r_arg3;
    Push r_this;
    Push r_arg;
    Jal CALL
    Pop r_arg;
    Pop r_this
  if G |- e : C (deterministic)
  and i_m = methodoffset(C, m)

c_expr(e1 == e2 ? e3 : e4) =
    c_expr(e1);
    Push r_res;
    c_expr(e2);
    Pop r_aux;
    Binop_= r_aux r_res r_aux;
    Bnz r_aux LST;
    c_expr(e4);
    Jump END;
LST:c_expr(e3);
END:Nop

Q: How to represent the auxiliary stack of saved registers?
- globally, accessed via system calls
  - could be merged with global call stack:
    - stack frames between return addresses
    - Pop can't affect return addresses, only Return can
- locally, each compartment keeps its own stack
  - would work well with all alts below

--------------------------------------------------------------------------------

  Variant #2: - everything directly via instructions
                - monitor call only for index_to_addr (later object allocation)
              - fine-grained micro-policy
              - TODO: still unclear what to do with the stack(s)
                - alt1: keep using monitor service for call stack
                - alt2: protected call stack outside the monitor
                        (micro-policy for call-stack protection)
                - alt3: lightweight return addr protection + only local stacks

c_expr(e.f) =
    c_expr(e);
    Const a r_aux;
    Binop_+ r_res r_aux r_aux;
    Load r_aux r_res
  if G |- e : C (deterministic)
  and a = fieldoffset(C, f)

c_expr(e.m(e')) =
    c_expr(e);
    Push r_res;
    c_expr(e');
    Pop r_aux;
    Push r_this;
    Push r_arg;
    Mov r_aux r_this;
    Mov r_res r_arg;
    Const a r_aux;
    Jal r_aux;
    Pop r_arg;
    Pop r_this
  if G |- e : C (deterministic)
  and a = CAT(C) + methodoffset(C, m)

c_expr(e1 == e2 ? e3 : e4) =
    c_expr(e1);
    Push r_res;
    c_expr(e2);
    Pop r_aux;
    Binop_- r_aux r_res r_aux;
    Bnz r_aux k;
    c_expr(e3);
    Const 1 r_aux;                        } ugly relative jump
    Bnz k' r_aux;                         } ^^^^^^^^^^^^^^^^^^
    c_expr(e4)
  if k = |c_expr(e3)| + 2
  and k' = |c_expr(e4)|
