================================================================================
| Syntax
================================================================================

What we call names hereafter are naturals. When compiling to a
realistic architecture, we will require them to be word-sized.

l - class name -- mapped to class declarations L (LT)
f - field index (natural)
m - method index (natural)
o - object names -- mapped to object declarations O (OT)

In our setting, only object names are values, and only class names are types.

--------------------------------------------------------------------------------
| Programs
--------------------------------------------------------------------------------

A ::= (LT, OT)                   program

LT ::= partial map from l to L   class table
       with finite domain

OT ::= partial map from o to O   object table
       with finite domain

L ::=
  class {                        class definition
    l1, ..., ln;                   field declarations
    M1, ..., Mp                    method definitions
  }
  where n, p >= 0

O ::=
  obj l { o1, ..., on }          object definition
  where n >= 0

M ::=                            method declaration
  lr (la) {                        result and argument types 
    e                              method body
  }

x ::=
  | this                         object on which the method was called
  | arg                          object the method was provided as argument

e ::=                            expressions
  | x                              variables
  | o                              object reference
  | e.f                            field selection
  | e.f := e                       field update
  | e.m(e)                         method call
  | e == e ? e : e                 object identity test
  | e; e                           sequence
  | exit e                         exit

================================================================================
| Operational semantics
================================================================================

We introduce a big-step semantics which gives a high-level intuition,
together with a small-step semantics which relates well to low-level
evaluation. We relate the two.

--------------------------------------------------------------------------------
| Def.: Values
--------------------------------------------------------------------------------

A value is an object name o.

--------------------------------------------------------------------------------
| Prop.: Equality on values is decidable
--------------------------------------------------------------------------------
| forall o o', {o = o'} + {o <> o'}
--------------------------------------------------------------------------------

Proof: Object names are naturals.


Big-step semantics
==================

The big-step semantics is described by statements of the form:

  LT; (ot, oa) |- (OT, e) ==> (OT', r)

  where r ::= Val o | Exit o

where LT is the code of the program; ot is the current "this" object;
oa is the current argument object; OT is the state before evaluation;
e is the expression to evaluate; OT' is the state after evaluation;
and r is the result, embedding the result value o that was obtained
either by an regular evaluation of e (Val o) or by a premature call to
exit (Exit o).

Evaluations to (Val o) and (Exit o) are both proper ways to
terminate. Thus we define proper evaluation and termination in terms
of those by a statement

  LT; (ot, oa) |- (OT, e) ==> (OT', o)

defined as follows:

  LT; (ot, oa) |- (OT, e) ==> (OT', Val o)
  ---------------------------------------- EVALVAL
  LT; (ot, oa) |- (OT, e) ==> (OT', o)

  LT; (ot, oa) |- (OT, e) ==> (OT', Exit o)
  ----------------------------------------- EVALEXIT
  LT; (ot, oa) |- (OT, e) ==> (OT', o)


Notes:

(1) Our fields are private with class granularity, i.e.:
* two objects of different classes cannot access each other's fields;
* different object instances of the same class can access each other's
private fields.

(2) Classes and objects have names, which are natural numbers. Fields
(resp. methods) are referred by their position in the class definition
of the object.


------------------------------------------- THIS
LT; (ot, oa) |- (OT, this) ==> (OT, Val ot)


------------------------------------------ ARG
LT; (ot, oa) |- (OT, arg) ==> (OT, Val oa)


--------------------------------------- OBJ
LT; (ot, oa) |- (OT, o) ==> (OT, Val o)


LT; (ot, oa) |- (OT1, e) ==> (OT2, o)
OT2(o) = obj l { o1, ..., on }
OT2(ot) = obj l { ... }              ensures field privacy
                                     (granularity: class) (BCP:??)
f in [1,n]                           (BCP:??)
                                     (YJ: More explanations on this in
				     (1) and (2) above, which we
				     should keep in the document. If
				     this is not enough, could I have
				     a more explicit question?)
-------------------------------------------- SEL
LT; (ot, oa) |- (OT1, e.f) ==> (OT2, Val oi)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val o)
LT; (ot, oa) |- (OT2, e2) ==> (OT3, Val o')
A = (LT, OT)
OT3(o) = obj l { o1, ..., on }
OT3(ot) = obj l { ... }
f in [1,n]
OT3' = OT3 with o => { o1, ..., of-1, o', of+1, ..., on }
--------------------------------------------------------- UPD
LT; (ot, oa) |- (OT1, e1.f := e2) ==> (OT3', Val o')


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val ot')
LT; (ot, oa) |- (OT2, e2) ==> (OT3, Val oa')
OT3(ot') = obj l { o1, ..., on }
LT(l) = class { ... ; M1, ..., Mp }
Mj = lr (la) { e }
m in [1,p]
LT; (ot', oa') |- (OT3, e) ==> (OT4, r)
-------------------------------------------- CALL
LT; (ot, oa) |- (OT1, e1.m(e2)) ==> (OT4, r)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val o12)
LT; (ot, oa) |- (OT2, e2) ==> (OT3, Val o12)
LT; (ot, oa) |- (OT3, e3) ==> (OT4, r)
------------------------------------------------------ TESTEQ
LT; (ot, oa) |- (OT1, e1 == e2 ? e3 : e4) ==> (OT4, r)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val o1)
LT; (ot, oa) |- (OT2, e2) ==> (OT3, Val o2)
o1 <> o2
LT; (ot, oa) |- (OT3, e4) ==> (OT4, r)
----------------------------------------------- TESTNEQ
LT; (ot, oa) |- e1 == e2 ? e3 : e4 ==> (OT4, r)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val o)
LT; (ot, oa) |- (OT2, e2) ==> (OT3, r)
-------------------------------------------- SEQ
LT; (ot, oa) |- (OT1, (e1; e2)) ==> (OT3, r)


LT; (ot, oa) |- (OT, e) ==> (OT', Val o)
---------------------------------------------- EXIT
LT; (ot, oa) |- (OT, exit e) ==> (OT', Exit o)


LT; (ot, oa) |- (OT, e) ==> (OT', Exit o)
------------------------------------------- EXITSEL
LT; (ot, oa) |- (OT, e.f) ==> (OT', Exit o)


LT; (ot, oa) |- (OT, e) ==> (OT', Exit o)
------------------------------------------------- EXITUPDLEFT
LT; (ot, oa) |- (OT, e.f := e') ==> (OT', Exit o)


LT; (ot, oa) |- (OT1, e) ==> (OT2, Val o)
LT; (ot, oa) |- (OT2, e') ==> (OT3, Exit o')
--------------------------------------------------- EXITUPDRIGHT
LT; (ot, oa) |- (OT1, e.f := e') ==> (OT3, Exit o')


LT; (ot, oa) |- (OT1, e) ==> (OT2, Exit o)
----------------------------------------------- EXITCALLLEFT
LT; (ot, oa) |- (OT1, e.m(e')) ==> (OT2, Exit o)


LT; (ot, oa) |- (OT1, e) ==> (OT2, Val o)
LT; (ot, oa) |- (OT2, e') ==> (OT3, Exit o)
----------------------------------------------- EXITCALLRIGHT
LT; (ot, oa) |- (OT, e.m(e')) ==> (OT', Exit o)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Exit o)
----------------------------------------------------------- EXITTESTLEFT
LT; (ot, oa) |- (OT1, e1 == e2 ? e3 : e4) ==> (OT2, Exit o)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Val o1)
LT; (ot, oa) |- (OT2, e2) ==> (OT3, Exit o)
----------------------------------------------------------- EXITTESTRIGHT
LT; (ot, oa) |- (OT1, e1 == e2 ? e3 : e4) ==> (OT3, Exit o)


LT; (ot, oa) |- (OT1, e1) ==> (OT2, Exit o)
------------------------------------------------- EXITSEQ
LT; (ot, oa) |- (OT1, (e1; e2)) ==> (OT3, Exit o)


Small-step semantics
====================

The small-step semantics is described by statements of the form:

  LT |- Cfg --> Cfg'

where LT is the constant part of the program (its code); Cfg is the
configuration being reduced; and Cfg' the reduced configuration.


E ::=                            flat evaluation contexts
  | [].f
  | [].f := e2
  | o1.f := []
  | [].m(e)
  | o.m([])
  | [] == e2 ? e3 : e4
  | o1 == [] ? e3 : e4
  | []; e
  | exit []


K ::= []                         continuations (lists of flat eval contexts)
  | E :: K

CS ::= []                        call stack
  | (ot, oa, K) :: CS

Cfg ::=                          reduction configurations
  | (OT, CS, ot, oa, K, e)


----------------------------------- THIS
LT |- (OT, CS, ot, oa, K, this) -->
      (OT, CS, ot, oa, K,   ot)


---------------------------------- ARG
LT |- (OT, CS, ot, oa, K, arg) -->
      (OT, CS, ot, oa, K,  oa)


------------------------------------------ SEL_PUSH
LT |- (OT, CS, ot, oa,         K, e.f) -->
      (OT, CS, ot, oa, [].f :: K,   e)


OT(o) = obj l { o1, ..., on }
OT(ot) = obj l { ... }               field privacy (granularity: class)
f in [1,n]
----------------------------------------- SEL_POP
LT |- (OT, CS, ot, oa, [].f :: K,  o) -->
      (OT, CS, ot, oa,         K, of)


------------------------------------------------------ UPD_PUSH
LT |- (OT, CS, ot, oa,               K, e.f := e') -->
      (OT, CS, ot, oa, [].f := e' :: K,         e)


----------------------------------------------- UPD_SWITCH
LT |- (OT, CS, ot, oa, [].f := e' :: K,  o) -->
      (OT, CS, ot, oa,  o.f := [] :: K, e')


OT(o) = obj l { o1, ..., on }
OT(ot) = obj l { ... }
f in [1,n]
OT' = OT with o => { o1, ..., of-1, o', of+1, ..., on }
------------------------------------------------------- UPD_POP
LT |- (OT,  CS, ot, oa, o.f := [] :: K, o') -->
      (OT', CS, ot, oa,              K, o')


--------------------------------------------------- CALL_PUSH
LT |- (OT, CS, ot, oa,             K, e1.m(e2)) -->
      (OT, CS, ot, oa, [].m(e2) :: K,       e1)


--------------------------------------------- CALL_SWITCH
LT |- (OT, CS, ot, oa, [].m(e2) :: K, o1) -->
      (OT, CS, ot, oa, o1.m([]) :: K, e2)

OT(ot') = obj l { o1, ..., on }
LT(l) = class { ... ; M1, ..., Mp }
Mj = lr (la) { e }
m = j in [1,p]
---------------------------------------------------------------- CALL_POP
LT |- (OT,                CS, ot,  oa,  ot'.m([]) :: K, oa') -->
      (OT, (ot, oa, K) :: CS, ot', oa',              K,   e)


---------------------------------------------------- RETURN
LT |- (OT, (ot', oa', K) :: CS, _,     _, [], o) -->
      (OT,                  CS, ot', oa',  K, o)


----------------------------------------------------------------------- TEST_PUSH
LT |- (OT, CS, ot, oa,                       K, e1 == e2 ? e3 : e4) -->
      (OT, CS, ot, oa, [] == e2 ? e3 : e4 :: K,                 e1)


------------------------------------------------------- TEST_SWITCH
LT |- (OT, CS, ot, oa, [] == e2 ? e3 : e4 :: K, o1) -->
      (OT, CS, ot, oa, o1 == [] ? e3 : e4 :: K, e2)


------------------------------------------------------ TEST_POP_EQ
LT |- (OT, CS, ot, oa, o == [] ? e3 : e4 :: K,  o) -->
      (OT, CS, ot, oa,                      K, e3)

o <> o'
------------------------------------------------------ TEST_POP_NEQ
LT |- (OT, CS, ot, oa, o == [] ? e3 : e4 :: K, o') -->
      (OT, CS, ot, oa,                      K, e4)


-------------------------------------------------- SEQ_PUSH
LT |- (OT, CS, ot, oa,             K, (e; e')) -->
      (OT, CS, ot, oa, ([]; e') :: K,       e)


--------------------------------------------- SEQ_POP
LT |- (OT, CS, ot, oa, ([]; e') :: K,  o) -->
      (OT, CS, ot, oa,             K, e')


------------------------------------------------ EXIT_PUSH
LT |- (OT, CS, ot, oa,            K, exit e) -->
      (OT, CS, ot, oa, exit [] :: K,      e)


Notations for reductions between configurations
===============================================

For every class table LT, we define three relations -->_LT, -/->_LT
and -->*_LT between configurations as follows:

Cfg -->_LT Cfg' ::= LT |- Cfg --> Cfg'

Cfg -/->_LT Cfg' ::= ~ (Cfg -->_LT Cfg')
                    i.e. (Cfg -->_LT Cfg') -> _|_

-->*_LT ::= the reflexive and transitive closure of -->_LT


Semantics of programs
=====================

--------------------------------------------------------------------------------
| Def.: Final configurations
--------------------------------------------------------------------------------

  LT(0) = class { 0 (0) { _ } }
  OT(o) = obj 0 { ... }
  ---------------------------------
  LT |- final (OT, [], 0, 0, [], o)

  LT(0) = class { 0 (0) { _ } }
  OT(o) = obj 0 { ... }
  ---------------------------------------------
  LT |- final (OT, CS, ot, oa, exit [] :: K, o)

--------------------------------------------------------------------------------
| Def.: Program termination
--------------------------------------------------------------------------------

  A = (LT, OT)
  LT(0) = class { ...; 0 (0) { e } }
  OT(0) = obj 0 { ... }
  (OT, [], 0, 0, [], e) -->*_LT Cfg
  LT |- final Cfg
  ----------------------------------------------------
  |- terminates A

Note: We later define evaluable programs, which can be seen as
  particular well-typed programs which trivially satisfy the two
  extra conditions we ask for, that is:
    LT(0) = class { ...; 0 (0) { e } }
    OT(0) = obj 0 { ... }.

Note: Programs also have a result value, but in this document we only
care about termination.


Properties
==========

--------------------------------------------------------------------------------
| Prop.: Relation between big-step and small-step semantics (hopefully)
--------------------------------------------------------------------------------
| forall LT OT OT' ot oa e o,
|   LT; (ot, oa) |- (OT, e) ==> (OT', o)
|      <->
|   exists Cfg = (OT', _, _, _, _, o),
|     (OT, [], ot, oa, [], e) -->*_LT Cfg
|     /\ LT |- final Cfg
|   )
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Prop.: Values do not reduce
--------------------------------------------------------------------------------
| forall o LT OT ot oa Cfg',
|   (OT, [], ot, oa, [], o) -/->_LT Cfg'
--------------------------------------------------------------------------------

Proof: No rule applies with such a configuration in the left-hand side.

--------------------------------------------------------------------------------
| Prop.: Reduction is deterministic
--------------------------------------------------------------------------------
| forall LT Cfg Cfg' Cfg'',
|    Cfg -->_LT Cfg'  ->
|    Cfg -->_LT Cfg'' ->
|      Cfg' = Cfg''
--------------------------------------------------------------------------------

Proof: We show that at most one rule applies with Cfg as the left-hand
side. Let (_, _, _, _, K, e) = Cfg. By case on e:
* if e is not an o:
    at most one rule applies depending on e (syntax-directed):
      this -> THIS, arg -> ARG, e.f -> SEL_PUSH, e.f := e' -> UPD_PUSH,
      e.m(e') -> CALL_PUSH, e1 == e2 ? e3 : e4 -> TEST_PUSH,
      (e; e') -> SEQ_PUSH, exit e -> EXIT_PUSH;
* if e is an o:
  * if K is empty, only RETURN may apply;
  * otherwise, by case on the head E of K:
    * if E is o == [] ? e3 : e4, then at most one rule applies, chosen
      between TEST_POP_EQ and TEST_POP_NEQ which are mutually
      exclusive;
    * otherwise, at most one rule applies depending on E
      (syntax-directed):
        [].f -> SEL_POP,
        [].f := e2 -> UPD_SWITCH, o1.f := [] -> UPD_POP,
        [].m(e) -> CALL_SWITCH, o.m([]) -> CALL_POP,
        [] == e2 ? e3 : e4 -> TEST_SWITCH,
        []; e -> SEQ_POP,
        exit [] -> no rule.


================================================================================
| Partial programs
================================================================================

--------------------------------------------------------------------------------
| Syntax
--------------------------------------------------------------------------------

P ::= (                           partial program
  I,                                import declarations
  A,                                definitions (syntactically like a
                                    program defined above)
  E                                 export declarations
)

I ::= D

E ::= D

D ::= (LD, OD)

LD ::= partial map from l to LL  class declaration table

OD ::= partial map from o to OO  object declaration table

LL ::=
  class decl {                    class declaration
    N1, ..., Np                     method signatures
  }
  where p >= 0

OO ::=
  obj decl l                      object declaration

N ::=
  lr (la)

--------------------------------------------------------------------------------
| Def.: Partial-program well-formedness
--------------------------------------------------------------------------------

|- I wf
I |- E wf
E |- A wf
---------------
|- (I, A, E) wf


Well-formedness of import declarations
======================================

Import declarations should be self-contained; that is, they should
provide declarations for every class that is mentionned in a method
signature or in an object declaration.

I = (LI, OI)
forall l in dom(LI),
  let class decl { N1, ..., Np } = LI(l) in
  forall i in [1,p],
    let lr (la) = Ni in
    lr in dom(LI) /\ la in dom(LI)
forall o in dom(OI),
  let obj decl l = OI(o) in
  l in dom(LI)
-------------------------------------------
|- I wf


Well-formedness of export declarations (w.r.t. import declarations)
===================================================================

Export declarations should not redeclare imported definitions, and
should not mention classes that are neither imported nor exported.

I = (LI, OI)
E = (LE, OE)
dom(LI) inter dom(LE) = empty_set
dom(OI) inter dom(OE) = empty_set
forall l in dom(LE),
  let class decl { N1, ..., Np } = LE(l) in
  forall i in [1,p],
    let lr (la) = Ni in
    (lr in dom(LE) \/ lr in dom(LI))
    /\
    (la in dom(LE) \/ la in dom(LI))
forall o in dom(OE),
  let obj decl l = OE(o) in
  l in dom(LE)
---------------------------------------------
I |- E wf


Well-formedness of high-level programs (w.r.t. export declarations)
===================================================================

Programs should have a direct match with their export declarations;
that is all we require for well-formedness: we don't check the types
of the method bodies nor of the instance fields.

Note: in the high level, there is a unique matching export declaration
for each program; this is because in this level programs already carry
the types.

E = (LE, OE)
A = (LT, OT)
dom(LE) = dom(LT)
dom(OE) = dom(OT)
forall l in dom(LE),
  let class decl { N1, ..., Np } = LE(l) in
  let class { ... ; M1, ..., Mp' } = LT(l) in
  p = p' /\
    forall i in [1,p],
    let lr (la) = Ni in
    let lr' (la') { _ } = Mi in
    lr = lr' /\ la = la'
forall o in dom(OE),
  let obj decl l = OE(o) in
  let class { l1, ..., ln'; ... } = LT(l) in
  let obj l' { o1, ..., on } = OT(o) in
  l = l' /\ n = n'
---------------------------------------------
E |- A wf

================================================================================
| Type system
================================================================================

Partial program typing
======================

|- (I, A, E) wf
forall l in dom(LT),
  I; A |- LT(l) @ l ok
forall o in dom(OT),
  I; A |- OT(o) ok
----------------------
I |- A : E


Object definition typing
------------------------

I = (_, OI)
A = (LT, OT)
LT(l) = class { l1, ..., ln; ... }            can only define objects of classes
forall i in [1,n],                                           in the same program
  OD(oi) = obj decl li \/
    OT(oi) = obj li { ... }
----------------------------------
I; A |- obj l { o1, ..., on } ok


Class definition typing
-----------------------

D = (LD, _)
A = (LT, _)
forall i in [1,n],
  li in dom(LD) \/ li in dom(LT)
forall j in [1,p],
  D; A |- Mj @ lt ok
--------------------------------------------------
D; A |- class { l1, ..., ln; M1, ..., Mp } @ lt ok


Method typing
-------------

G = {this:lt, arg:la}
D; A; G |- e : lr
-----------------------------
D; A |- lr (la) { e } @ lt ok


Expression typing
-----------------

We define typing environments as:

                           G ::= {this:lt, arg:la}

------------------- TVAR
D; A; G |- x : G(x)


A = (_, OT)
OT(o) = obj l { ... }
--------------------- TOBJ
D; A; G |- o : l


D = (_, OD)
OD(o) = obj decl l
------------------ TOBJ'
D; A; G |- o : l


D; A; G |- e : l
G(this) = l                                   ensures field privacy
A = (LT, _)
LT(l) = class { l1, ..., ln; ... }
f in [1,n]
---------------------------------- TSEL
D; A; G |- e.f : lf



D; A; G |- e : l
G(this) = l                                   ensures field privacy
A = (LT, _)
LT(l) = class { l1, ..., ln; ... }
f in [1,n]
D; A; G |- e' : lf
---------------------------------- TUPD
D; A; G |- e.f := e' : lf


D; A; G |- e : l
A = (LT, _)
LT(l) = class { ...; M1, ..., Mp }
m in [1,p]
Mm = lr (la) { _ }
D; A; G |- ea : la
---------------------------------- TCALL
D; A; G |- e.m(ea) : lr


D; A; G |- e : l
D = (LD, _)
LD(l) = class decl { N1, ..., Np }
m in [1,p]
Sm = lr (la)
D; A; G |- ea : la
---------------------------------- TCALL'
D; A; G |- e.m(ea) : lr


D; A; G |- e1 : l'
D; A; G |- e2 : l'
D; A; G |- e3 : l
D; A; G |- e4 : l
----------------------------------- TTEST
D; A; G |- (e1 == e2 ? e3 : e4) : l


D; A; G |- e : l
D; A; G |- e' : l'
----------------------- TSEQ
D; A; G |- (e; e') : l'


Note: Class 0 is the main class, see Evaluable programs right below.

D; A; G |- e : 0
--------------------- TEXIT
D; A; G |- exit e : l

--------------------------------------------------------------------------------
| Def.: Evaluable programs
--------------------------------------------------------------------------------

A program A is evaluable if typechecks with no import declarations
and a particular export declaration, which corresponds to the way
program evaluation is performed.

  (empty_map, empty_map) |- A : E
  E = D
  D = (LE, OE)
  LE(0) = class decl { 0 (0) }
  OE(0) = obj decl 0
  -------------------------------
  |- A evaluable


--------------------------------------------------------------------------------
| Def: Evaluable partial programs
--------------------------------------------------------------------------------

We say that a well-typed partial program (I, A, E) is evaluable when
  I = (empty_map, empty_map)
  LE(0) = class decl { 0 (0) }
  OE(0) = obj decl 0
where
  E = (LE, OE).

Note:
  (I, A, E) evaluable ->  |- A evaluable.

  However, it is possible for A to be evaluable without having
  (I, A, E) evaluable, e.g. if the partial program has useless import
  declarations.


--------------------------------------------------------------------------------
| Def.: Linkability
--------------------------------------------------------------------------------

Two well-typed partial programs are linkable when their definitions
do not overlap, their common import declarations match, and the
export declarations of one which correspond to import declarations of
the other also match with the other's declarations.

  P = (I, A, E)
  Q = (I', A', E')
  I |- A : E
  I' |- A' : E'
  |- exclusive_decls E E'
  |- import_export_compatible I E'
  |- import_export_compatible I' E
  |- same_common_decls I I'
  --------------------------------
  |- linkable P Q


  E = (LE, OE)
  E' = (LE', OE')
  dom(LE) inter dom(LE') = empty_set
  dom(OE) inter dom(OE') = empty_set
  ----------------------------------
  |- exclusive_decls E E'


  I = (LI, OI)
  E = (LE, OE)
  forall l in dom(LE) inter dom(LI),
    LE(l) = LI(l) /\
      forall o in dom(OI),
        OI(o) = obj decl l ->
          OE(o) = OI(o)
  dom(LT) inter dom(LT') = empty_set
  dom(OT) inter dom(OT') = empty_set
  ----------------------------------
  |- import_export_compatible I E


  I = D
  D = (LI, OI)
  I' = D'
  D' = (LI', OI')
  forall l in dom(LI) inter dom(LI'),
    LI(l) = LI'(l)
  forall o in dom(OI) inter dom(OI'),
    OI(o) = OI'(o)
  -----------------------------------
  |- same_common_decls I I'


--------------------------------------------------------------------------------
| Def.: Linking
--------------------------------------------------------------------------------

Two linkable (hence also well-typed) partial programs
  P = ((LI, OI), (LT, OT), (LE, OE))
  Q = ((LI', OI'), (LT', OT'), (LE', OE'))
can be linked to get a new partial program P /\/\ Q.

  P /\/\ Q ::= (
    ((LI - LE') union (LI' - LE), (OI - OE') union (OI' - OE)),
    (LT disjoint_union LT', OT disjoint_union OT'),
    (LE disjoint_union LE', OE disjoint_union OE')
  ) when |- linkable P Q

  where

    M - M' is defined
      * for any M and M' such that M(x) = M'(x)
        for all x in dom(M) inter dom(M')
      * as the partial map M restricted to
        domain dom(M) - dom(M')

    M union M' is defined (when applicable) as the partial map
      (M - M') disjoint_union M'

--------------------------------------------------------------------------------
| Th.: Linking preserves well-formedness
--------------------------------------------------------------------------------
| forall P Q, |- linkable P Q  ->  |- P /\/\ Q wf
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Prop.: Linking is symmetric
--------------------------------------------------------------------------------
| forall P Q, |- linkable P Q  ->
|             |- linkable Q P  ->
|             (Q /\/\ P = P /\/\ Q)
| forall P Q, |- linkable P Q  <->  |- linkable Q P
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Prop.: Linking is associative
--------------------------------------------------------------------------------
| forall P Q R, |- linkable P Q  ->  |- linkable (P /\/\ Q) R  ->
|               |- linkable Q R  ->  |- linkable P (Q /\/\ R) ->
|               (P /\/\ Q) /\/\ R = P /\/\ (Q /\/\ R)
| forall P Q R, (|- linkable P Q  /\  |- linkable (P /\/\ Q) R)
|                 <->
|               (|- linkable Q R  /\  |- linkable P (Q /\/\ R))
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Th.: Linking preserves well-typing (composition lemma)
--------------------------------------------------------------------------------
| forall P Q, |- linkable P Q  ->
|   let (I, A, E) = P in
|   let (I', A', E') = Q in
|   let (I'', A'', E'') = P /\/\ Q in
|   I |- A : E  ->
|   I' |- A' : E'  ->
|     I'' |- A'' : E''
--------------------------------------------------------------------------------


================================================================================
| Encodings
================================================================================

-------------------------------------------------------------------------------
| Unit
--------------------------------------------------------------------------------

obj tt : Unit { }

class Unit { }

--------------------------------------------------------------------------------
| Tuples
--------------------------------------------------------------------------------

For each tuple type T=(l1, ..., ln)

class decl Unit { }

class Tuple_T {
  l1 f1, ..., ln fn;
  l1 get_1(Unit) { this.f1 },
  ...
  ln get_n(Unit) { this.fn },
}

--------------------------------------------------------------------------------
| Booleans
--------------------------------------------------------------------------------

obj true : Bool { }
obj false : Bool { }
class Bool {
  /* auxiliary methods that could be defined outside */
  Bool neg(Unit) {
    this == true ? false : true;
  }

  Bool and(Bool b) {
    this == true ? b : false;
  }

  Bool or(Bool b) {
    /* this.neg(tt).and(b.neg(tt)).neg(tt); */
    this == true ? true : b;
  }
}

If then else via identity test, e.g. (b == true ? e1 : e2).

--------------------------------------------------------------------------------
| Naturals : requires dynamic allocation
--------------------------------------------------------------------------------

class decl Unit { }
obj decl tt

obj z : Nat { z }
class Nat {

  Nat pred;

  Nat pred(Unit) {
    return this.pred;
  }

  /* auxiliary methods that could be defined outside */

  Bool isZero(Unit) {
    this.pred(tt) == this ? true : false;
  }

  Nat succ(Unit) {
    new Nat(this)
  }

  Bool eq(Nat arg) {
    this.isZero(tt) ?
      arg.isZero(tt) :
      (arg.isZero(tt) ? false : this.pred(tt).eq(arg))
  }

  Nat add(Nat arg) {
    arg.isZero(tt) ?
      this :
      this.succ(tt).add(arg.pred(tt))
  }

  Nat mul(Nat arg) {
    arg.isZero(tt) ?
      z :
      this.mul(arg.pred(tt)).add(this)
  }

}


================================================================================
| Properties of our type system (bogus -- way too weak)
================================================================================

--------------------------------------------------------------------------------
| Progress
--------------------------------------------------------------------------------
| forall Cfg l I LT E G,
|   let (OT, _, _, _, _, e) = Cfg in
|   I |- (LT, OT) : E ->
|   I; (LT, OT); G |- e : l ->
|     is_value e \/ (exists Cfg', Cfg -->_LT Cfg')
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Preservation (Subject reduction)
--------------------------------------------------------------------------------
| forall Cfg Cfg' l I LT E G,
|   let (OT, _, _, _, _, e) = Cfg in
|   let (OT', _, _, _, _, e') = Cfg' in
|   I |- (LT, OT) : E ->
|   I; (LT, OT); G |- e : l ->
|   Cfg -->_LT Cfg' ->
|     I |- (LT, OT') : E /\
|     I; (LT, OT'); G |- e' : l
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Type safety
--------------------------------------------------------------------------------
| forall Cfg l I LT E G,
|   let (OT, _, _, _, _, e) = Cfg in
|   I |- (LT, OT) : E ->
|   I; (LT, OT); G |- e : l ->
|     is_value e \/
|     (exists Cfg', Cfg -->_LT Cfg' /\
|        let (OT', _, _, _, _, e') = Cfg' in
|          I |- (LT, OT') : E /\
|          I; (LT, OT'); G |- e' : l)
--------------------------------------------------------------------------------

================================================================================
| Observational equivalence
================================================================================

To keep our stronger than full abstraction corruption property simple
we stick to programs that correspond to low-level components, or to
sets of low-level components. However, to allow interaction with the
context, our notion of high-level programs will be well-typed
*partial* programs, which may include import declarations that will be
mapped to context definitions.

--------------------------------------------------------------------------------
| Def.: High-level program
--------------------------------------------------------------------------------

A high-level program is a well-typed partial program.

--------------------------------------------------------------------------------
| Def.: High-level context
--------------------------------------------------------------------------------

A high-level context C is a well-typed partial program. A program can
only be inserted in a linkable context. Inserting a program P in a
context C is linking, it yields a new high-level program:

     C[P] ::= P /\/\ C       when |- linkable C P

--------------------------------------------------------------------------------
| Def.: Closing contexts
--------------------------------------------------------------------------------

Given a program P and a context C, we say that C closes P when C is
linkable with P and inserting P in C gives an evaluable partial
program, that is:

   |- linkable C P
   C[P] evaluable
   -----------------
   |- closes C P

We define the set of closing contexts of a program P by:

  closing_contexts P ::= {C | |- closes C P}

--------------------------------------------------------------------------------
| Def.: Interface equivalence
--------------------------------------------------------------------------------

We say that two programs P and Q are interface equivalent when they
share the same import and export definitions.

  same_interface (I, A, E) (I', A', E') ::= (I = I') /\ (E = E')

--------------------------------------------------------------------------------
| Prop.: Characterization of interface equivalence for well-typed programs
--------------------------------------------------------------------------------
| forall ((I,A,E) = P) ((I',A',E') = Q),
|   I |- A : E  ->
|   I' |- A' : E'  ->
|     same_interface P Q <-> (closing_contexts P = closing_contexts Q)
--------------------------------------------------------------------------------

Proof: todo.

--------------------------------------------------------------------------------
| Def.: Observational equivalence
--------------------------------------------------------------------------------

Two well-typed programs P and Q are observationnally equivalent if
they are interface equivalent and, for any context C that closes them,
when separately placing the two in C, the two resulting programs
behave the same with respect to termination. That is:


  P = (I0, A0, E0)                  Note: same_interface P Q
  Q = (I0, A0', E0)
  I0 |- A0 : E0
  I0 |- A0' : E0
  forall C in closing_contexts P,
    let ((empty_map, empty_map), A, E) = C[P] in
    let ((empty_map, empty_map), A', E) = C[Q] in
    (E |- terminates B) <-> (E |- terminates B')
  ---------------------------------------------------------
  |- P ~ Q


================================================================================
| Intermediate machine
================================================================================

Here we present an abstract stack machine. The goal is to have an
intermediate language which offers a lower-level view, while still
being abstract (e.g. we allow unbounded stacks).

--------------------------------------------------------------------------------
| Informal overview
--------------------------------------------------------------------------------

A machine state is formed by:

* the currently running code;

* two registers, this and arg, that can only be changed upon calls and
  returns, one holding a reference to the current object, the other
  holding a reference to the current argument;

* a call stack that allows storing the current environment [1] before
  performing a call, so that it can be restored afterwards;

* a program which is a compartment table, each compartment
  corresponding to a high-level class and storing :

   (i) the code for its methods ;
   (ii) a local object table storing all of its instances ;
   (iii) a local stack used when executing a method of this
         compartment.

[1] registers + continuation code + expected type for returned value

The running code can only use the local stack owned by the class of
the object that is currently referenced by register this. Upon call,
we may switch compartments, and thus local stacks.

This prevents low-level methods from compromising the local stack used by a
caller of a different compartment. An attacker compromising a given
class won't be able to damage an uncompromised caller's user stack
before control gets back to this caller.

Partial programs are programs (compartment tables) together with
import and export declarations -- which can be thought of as a
contract. Only partial programs which have compatible contracts can be
linked together. For performing linking, we require the partial
programs to be *well-formed*, but their code is *not statically
typed*; so at linking nothing forces a partial program to obey the
typed part of its contract. It is at run time that the typed part of
the contracts is enforced -- through dynamic type checking.

--------------------------------------------------------------------------------
| Syntax
--------------------------------------------------------------------------------

l ::= n                    compartment name (where n is natural)
o ::= n                    instance name (where n is natural)
f ::= n                    field index (where n is natural)
m ::= n                    method index (where n is natural)

p ::= (                    partial program
    I                        import declarations
    LT,                      the actual program (as a compartment table)
    E                        export declarations
  )

I, E as in the high-level language

LT ::=                     compartment table
  partial map from l to L

L ::= {                    compartment
    M1, ..., Mp;             methods
    LOT;                     local instance table
    LS                       local stack
  }

  where   p >= 0

M ::=                      method
  code

LOT ::=                    local instance table
  partial map from o to LO_n  (each LOT has a fixed n)

LO_n ::= (o1, ..., on)     local instance definition

LS ::=                     local stack storing object references
    []
  | o :: local_stack

code ::=                   code
    []
  | instr :: code            list of instructions


Note: hereafter, "stack" always means "current local stack" when
describing an instruction; similarly, "push" and "pop" always refer to
operations on the current local stack.


instr ::=                  instruction
  | Nop
  | This                     push reg[this]
  | Arg                      push reg[arg]
  | Ref o                    push constant reference o
  | Select f                 field selection
                               pop, then push the value of field f of
                               the popped object
  | Call m                   method call
                               pop twice, then call method m of the
                               second popped object, using the first
                               popped object as argument
  | Return                   return from call (with result)
                               pop, then resume execution to the
			       caller after pushing popped value to
			       its local stack
  | B n                      unconditional forward jump
                               skip n instructions
  | Beq n                    object identity test
                               pop twice, then skip n instructions
			       (forward jump) if the two references
			       refer to the same object
  | Update f                 field update
                               pop twice, push back
  | Drop                     drop
                               pop, do nothing with the popped object
  | Halt                     halt the machine
                               top of current local stack is the
			       result

Note: At this level we make no distinction between inter- and intra-
compartment calls. If we were to need this distinction it would anyway
be lower level.


--------------------------------------------------------------------------------
| Def: Well-formedness
--------------------------------------------------------------------------------

|- I wf            same as in the high-level
I |- E wf          same as in the high-level
E |- LT wf
----------------
|- (I, LT, E) wf


E = (LE, OE)
dom(LE) = dom(LT)
dom(OE) = disjoint_union
            {dom(OLT) where {...; OLT; _} = LT(l) | l in dom(LT)}
forall l in dom(LE),
  let class decl { N1, ..., Np } = LE(l) in
  let { M1, ..., Mp'; _; _ } = LT(l) in
  p = p'
forall o in dom(OE),
  let obj decl l = OE(o) in
  let { ...; OLT; _ } = LT(l) in
  o in dom(OLT)
---------------------------------------------
E |- LT wf


Note: Because fields are private to the defining class we do not need
to statically enforce that they have the right type, since there is no
way for a class to trick another class into accessing its fields at
the wrong type. Everything another class can do to an object is call
its methods or test it for equality.


--------------------------------------------------------------------------------
| Semantics
--------------------------------------------------------------------------------

s ::= (                    machine state
  RF,                        a register file
  GS,                        a global call stack
  LT,                        a program (compartment table)
  code                       the currently running code
)

RF ::= (                   register file of immutable registers
  this => o,                 current instance
  arg => o                   current argument
)

GS ::= [] | (              call stack: to restore execution after a call
  lr,                        expected type for the result
  RF,                        register file to be restored
  code                       code to be executed after restoring
) :: GS


TODO: Think about the invariants we want; e.g. that "this" and "arg"
and all objects on local stacks always have a corresponding
declaration and definition. We probably need more sanity
checks, unless we can prove these invariants true when restricting to
well-formed programs.

Rules:

  ---------------------------------- NOP
  E |- (RF, GS, LT, Nop :: code) -->
       (RF, GS, LT,        code)

  code = i1 :: ... :: in :: code'
  ----------------------------------- B
  E |- (RF, GS,  LT, B n :: code) -->
       (RF, GS, LT',       code')

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; LS }
  LT' = LT with l => { M1, ..., Mp; LOT; o :: LS }
  ------------------------------------------------ REF
  E |- (RF, GS,  LT, Ref o :: code) -->
       (RF, GS, LT',          code)

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; LS }
  LT' = LT with l => { M1, ..., Mp; LOT; RF(this) :: LS }
  ------------------------------------------------------- THIS
  E |- (RF, GS,  LT, This :: code) -->
       (RF, GS, LT',         code)

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; LS }
  LT' = LT with l => { M1, ..., Mp; LOT; RF(arg) :: LS }
  ------------------------------------------------------ ARG
  E |- (RF, GS,  LT, Arg :: code) -->
       (RF, GS, LT', code)

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; o :: LS }
  OE(o) = obj decl l                    requiring l here ensures field
  LOT(o) = (o1, ..., on)                                       privacy
  f <= n
  LT' = LT with l => { M1, ..., Mp; LOT; of :: LS }
  ------------------------------------------------- SELECT
  E |- (RF, GS,  LT, Select f :: code) -->
       (RF, GS, LT',             code)

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; o' :: o :: LS }
  OE(o) = obj decl l                    requiring l here ensures field
  LOT(o) = (o1, ..., on)                                       privacy
  1 <= f <= n
  LOT' = LOT with o => (o1, ..., of-1, o', of+1, ..., on)
  LT' = LT with l => { M1, ..., Mp; LOT'; o' :: LS }
  ------------------------------------------------------- UPD
  E |- (RF, GS,  LT, Update f :: code) -->
       (RF, GS, LT',             code)

  E = (LE, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; oa' :: ot' :: LS }
  OE(ot') = obj decl l'
  l <> l'
  LT(l') = { M'1, ..., M'p'; LOT'; _ }
  LE(l') = class decl { N'1, ..., N'p' }
  m <= p'
  N'm = lr (la)                               /!\ see remark below
  OE(oa') = la
  M'm = code'
  LT' = LT with l => { M1, ..., Mp; LOT; LS }
  GS' = (lr, RF, code) :: GS
  RF' = (this => ot', arg => oa')
  ------------------------------------------- CALL
  E |- ( RF,  GS, LT,  Call m :: code) -->
       (RF', GS', LT',          code')

  Here we are able to infer the expected return type because we can
  only call methods that have a definition, and we have a matching
  declaration for each definition.


  E = (_, OE)
  GS = (lr, RF', code') :: GS'
  OE(RF(this)) = obj decl l
  OE(RF'(this)) = obj decl l'
  LT(l) = { M1, ..., Mp; LOT; o :: LS }
  OE(o) = lr
  if l = l' then
    LT(l') = { M'1, ..., M'p'; LOT'; LS' }
    LT' = LT with l => { M1, ..., Mp; LOT; LS }
                  l' => { M'1, ..., M'p'; LOT'; o :: LS' }
  else
    LT' = LT
  fi
  -------------------------------------------------------- RETURN
  E |- ( RF,  GS,  LT,  Return :: _) -->
       (RF', GS', LT',        code')

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; o :: o :: LS }
  LT' = LT with l => { M1, ..., Mp; LOT; LS }
  code = i1 :: ... :: in :: code'
  ------------------------------------------- BEQ-EQ
  E |- (RF, GS,  LT, Beq n :: code) -->
       (RF, GS, LT',         code')

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; o1 :: o2 :: LS }
  o1 <> o2
  LT' = LT with l => { M1, ..., Mp; LOT; LS }
  -------------------------------------------- BEQ-NEQ
  E |- (RF, GS,  LT, Beq n :: code) -->
       (RF, GS, LT',          code)

  E = (_, OE)
  OE(RF(this)) = obj decl l
  LT(l) = { M1, ..., Mp; LOT; o :: LS }
  LT' = LT with l => { M1, ..., Mp; LOT; LS }
  ------------------------------------------- DROP
  E |- (RF, GS,  LT, Drop :: code) -->
       (RF, GS, LT',         code)


Semantics of programs
=====================

--------------------------------------------------------------------------------
| Def.: Final states
--------------------------------------------------------------------------------

  E = (LE, OE)
  LE(0) = class decl { 0 (0) }
  LT(0) = { M1; LOT; o :: [] }
  OE(o) = obj decl 0
  -------------------------------------------
  E |- final ((0, 0), [], LT, Return :: code)


  E = (LE, OE)
  LE(0) = class decl { 0 (0) }
  OE(RF(this)) = obj decl l
  LT(l) = { ...; LOT; o :: _ }
  OE(o) = obj decl 0
  -------------------------------------
  E |- final (RF, GS, LT, Halt :: code)


--------------------------------------------------------------------------------
| Def.: Program termination
--------------------------------------------------------------------------------

  E = (LE, OE)
  LE(0) = class decl { 0(0) }
  OE(0) = obj decl 0
  LT(0) = { M1; _; _ }
  M1 = code
  ((0, 0), [], LT, code, Running) -->*_E s'
  E |- final s'
  -----------------------------------------
  E |- terminates LT

Note: Programs also have a final result, but here we only care about
termination.

--------------------------------------------------------------------------------
| Linking
--------------------------------------------------------------------------------

  |- p wf
  |- q wf
  p = (I, LT, E)
  q = (I', LT', E')
  |- exclusive_decls E E'
  |- import_export_compatible I E'
  |- import_export_compatible I' E
  |- same_common_decls I I'
  --------------------------------
  |- linkable p q

  p /\/\ q ::= (
    ((LI - LE') union (LI' - LE), (OI - OE') union (OI' - OE)),
    LT disjoint_union LT',
    (LE disjoint_union LE', OE disjoint_union OE')
  ) when |- linkable p q

--------------------------------------------------------------------------------
| Prop.: Linking preserves well-formedness
--------------------------------------------------------------------------------
| forall p q, (|- linkable p q) -> well_formed (p /\/\ q)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Compilation
--------------------------------------------------------------------------------

Compilation of expressions
--------------------------

  Intuitive invariant, assuming a complete source program:

    If the source expression is a terminating expression:

    After the execution of the compiled expression, the current
    instance is the same as before its execution, and exactly one new
    object reference has been pushed on the local stack. This
    reference is o, where o is the unique object reference that the
    source expression reduces to.

    Otherwise:

    The execution of the compiled expression goes on forever.

  comp_expr(this) = This

  comp_expr(arg) = Arg

  comp_expr(o) = Ref o

  comp_expr(e.f) =
     comp_expr(e);
     Select f

  comp_expr(e.f := e') =
     comp_expr(e);
     comp_expr(e');
     Update f

  comp_expr(e.m(e')) =
     comp_expr(e);
     comp_expr(e');
     Call m

  comp_expr(e1 == e2 ? e3 : e4) =
     comp_expr(e1);
     comp_expr(e2);
     Beq EQ;       (note: these are indeed relative forward jumps, so this works)
     comp_expr(e4);
     B END;
EQ:  comp_expr(e3);
END: Nop

  comp_expr(e; e') =
     comp_expr(e);
     Drop;
     comp_expr(e')

  comp_expr(exit e) =
     comp_expr(e);
     Halt

Compilation of methods
----------------------

  comp_meth(lr (la) { e }) = comp_expr(e)

Compilation of classes
----------------------

  comp_class(class { l1, ..., ln; M1, ..., Mp }, OT, l) =
    { comp_meth(M1), ..., comp_meth(Mp); extract_objects(OT, l); [] }

  where extract_objects(OT, l) is a partial map defined only for
        all o such that OT(o) = obj l { o1, ..., on },
        which maps o to (o1, ..., on).

Compilation of programs
-----------------------

  comp_prog(LT, OT) = LT'

  where LT' is a partial map with domain dom(LT)
        such that for every l in dom(LT),
        LT'(l) = comp_class(LT(l), OT, l)

Compilation of partial programs
-------------------------------

  We erase types in the actual program (A) and keep the type
  information (I and E) separately.

  comp(I, A, E) = (I, comp_prog(A), E)

--------------------------------------------------------------------------------
| Prop.: Separate compilation
--------------------------------------------------------------------------------
| forall P Q, |- linkable P Q ->
|   linkable comp(P) comp(Q)
|     /\
|   comp(P /\/\ Q) = comp(P) /\/\ comp(Q)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Partial decompilation (failed attempt at a more direct approach)
--------------------------------------------------------------------------------

See decomp.ml.

--------------------------------------------------------------------------------
| Prop.: Reconstitution of expressions
--------------------------------------------------------------------------------
| forall e, decomp_code (comp_expr e) = e.
--------------------------------------------------------------------------------

Problem: Decompilation is only partial at the moment and seems hard
for tricky programs. Method bodies in the low-level may correspond to
ill-typed high-level expressions or even no high-level expressions at
all.

================================================================================
| Trace semantics
================================================================================

--------------------------------------------------------------------------------
| Labelled reduction
--------------------------------------------------------------------------------

We define a labelled reduction of the form:

            gamma
  E |- State --> State'

alpha ::=
  | tau        internal step taken by the program
  | a          observable action and origin

a ::=          observable action and origin
  | gamma ?      observable action performed by the context
  | gamma !      observable action performed by the program

gamma ::=          observable action
  | o.m(o')      cross-boundary call
  | o            cross-boundary return
  | tick         program termination

In a given State, the control is either held by the program or by the
context. Internal steps always preserve control ownership, while
cross-boundary calls and returns always transfer control (either from
the program to the context, or from the context to the program).

State ::=
  PrgState (  the program has control
    RF,          register file
    GSP,         program's view on the call stack
    LT,          program's compartment table
    code,        code being executed
    I,           current information about the context's definitions
                 (stored as import declarations)
    status       informs whether program execution is over
  )
| CtxState (   the context has control
    /,           register file unknown to the program
    GSC,         program's view on the call stack
    LT,          program's compartment table
    /,           code being executed unknown to the program
    I,           current information about the context's definitions
                 (stored as import declarations),
    status       informs whether program execution is over
  )

status ::= Running | Halted

GSP ::=        program's view on the call stack
               when the program has control
  GS
| GS ::          program internal call frames
        GSC      remainder of the global stack

GSC ::=        program's view on the call stack
               when the context has control
  lr?
| lr?            top context call frame return type, if known to the program
      :: GSP     remainder of the call stack

lr? ::=        option type
  lr | /


1 - Internal program reductions
===============================


E |- (RF, GS, LT, code) --> (RF', GS', LT', code')
match GSP with
| GS ->
    GSP' = GS'
| GS :: GSC ->
    GSP' = GS' :: GSC
----------------------------------------------------- TAU
                                                  tau
E |- PrgState ( RF,  GSP,  LT,  code, I, Running) -->
     PrgState (RF', GSP', LT', code', I, Running)


2 - Call from context code to program code
==========================================


I = (LI, OI)
E = (LE, OE)
ot' in dom(OE)                            ot' is program-defined
OE(ot') = obj decl l
LE(l) = class decl { N1, ..., Np }
LT(l) = class { M1, ..., Mp }
m in [1,p]                                its class provides method m
Nm = lr (la)                              with signature lr (la)
Mm = code'
RF' = (this => ot', arg => oa')
if oa' in dom(OE) then
  la in dom(LE)
  OE(oa') = obj decl la                   oa' is program-defined
  I' = I                                  with an appropriate type
else if oa' in dom(OI) then
  la in dom(LI)
  OI(oa') = obj decl la                   oa' is context-defined
  I' = I                                  with an appropriate type
else
  la in dom(LI)
  OI' = OI with oa' => obj decl la        first time oa' is encountered
  I' = (LI, OI')                          keep track of its type
fi
match GSC with
| / :: GSP ->
    GSP' = [] :: lr :: GSP
| / ->
    GSP' = [] :: lr
end
----------------------------------------------------------- CALL?
                                               ot'.m(oa') ?
E |- CtxState (  /,  GSC, LT,     /,  I, Running) -->
     PrgState (RF', GSP', LT, code', I', Running)


3 - Return from context code to program code
============================================


I = (LI, OI)
E = (LE, OE)
LT(l) = { M1, ..., Mp; OLT; LS }
LT' = LT with l => { M1, ..., Mp; OLT; o :: LS }
GS = (lr, RF', code') :: GS'
if o in dom(OE) then
  lr in dom(LE)
  OE(o) = obj decl lr                     o is program-defined
  I' = I                                  with an appropriate type
else if o in dom(OI) then
  lr in dom(LI)
  OI(o) = obj decl lr                     o is context-defined
  I' = I                                  with an appropriate type
else
  lr in dom(LI)
  OI' = OI with o => obj decl lr          first time o is encountered
  I' = (LI, OI')                          keep track of its type
fi
--------------------------------------------------------- RET?
                                                      o ?
E |- CtxState (  /, / :: GSP, LT,     /,  I, Running) -->
     PrgState (RF',      GSP, LT, code', I', Running)


4 - Call from program code to context code
==========================================


I = (LI, OI)
E = (LE, OE)
OE(RF(this)) = obj decl l
LT(l) = { M1, ..., Mp; OLT; oa' :: ot' :: LS }
LT' = LT with l => { M1, ..., Mp; OLT; LS }
code = Call m :: code'
ot' in dom(OI)
OI(ot') = lt'
lt' in dom(LI)
LI(lt') = { N1, ..., Np }
1 <= m <= p
Nm = lr (la')
if oa' in dom(OE) then
  la' in dom(LE)
  OE(oa') = obj decl la'
else
  oa' in dom(OI)
  la' in dom(LI)
  OI(oa') = obj decl la'
fi
GS' = (lr, RF, code') :: GS
match GSP with
| GS :: GSC ->
    GSP' = GS' :: GSC
| GS ->
    GSP' = GS'
-------------------------------------------------------------- CALL!
                                                  ot'.m(oa') !
E |- PrgState (RF,       GSP,  LT, code, I, Running) -->
     CtxState ( /, / :: GSP', LT',    /, I, Running)


5 - Return from program code to context code
============================================


I = (LI, OI)
E = (LE, OE)
OE(RF(this)) = obj decl l
LT(l) = { M1, ..., Mp; OLT; o :: LS }
LT' = LT with l => { M1, ..., Mp; OLT; LS }
code = Return :: _
if o in dom(OE) then
  lr in dom(LE)
  OE(o) = obj decl lr
else
  o in dom(OI)
  lr in dom(LI)
  OI(o) = obj decl lr
fi
match GSC with
| lr :: GSP ->
    GSC' = / :: GSP
| lr ->
    GSC' = /
end
-------------------------------------------------------- RET!
                                                     o !
E |- PrgState (RF, [] :: GSC,  LT, code, I, Running) -->
     CtxState ( /,      GSC', LT',    /, I, Running)


6 - Termination from context code
=================================

--------------------------------------------- TICK?
                                       tick ?
E |- CtxState (/, /, LT, /, I, Running) -->
     CtxState (/, /, LT, /, I,  Halted)

7 - Termination from program code
=================================

E = (LE, OE)
LE(0) = class decl { 0 (0) } 
LT(0) = { M1, ..., Mp; OLT; o :: [] }
OE(o) = obj decl 0
---------------------------------------------------------------- TICK!RET
                                                          tick !
E |- PrgState ((0, 0), [], LT, Return :: code, I, Running) -->
     PrgState ((0, 0), [], LT,           code, I,  Halted)

E = (LE, OE)
I = (LI, OI)
OE(RF(this)) = obj decl l
LT(l) = { M1, ..., Mp; OLT; o :: [] }
if 0 in dom(LE) then
  OE(o) = obj decl 0
else
  0 in dom(LI)
  o in dom(OI)
---------------------------------------------------------- TICK!HALT
                                                    tick !
E |- PrgState (RF, [], LT, Halt :: code, I, Running) -->
     PrgState (RF, [], LT, Halt :: code, I,  Halted)


--------------------------------------------------------------------------------
| Traces
--------------------------------------------------------------------------------

t ::= a word over alphabet a (as defined above).

--------------------
       empty_word
E |- State ==> State

          alpha
E |- State --> State'
---------------------
      as_word(alpha)
E |- State ==> State'

  where as_word(tau) = empty_word
        forall a, as_word(a) = a (as a word of length 1)

            t
E |- State ==> State'
             u
E |- State' ==> State''
-----------------------
           t.u
E |- State ==> State''

--------------------------------------------------------------------------------
| Trace dualization
--------------------------------------------------------------------------------

We define dualization on letters as:

/(gamma ?) = gamma !
/(gamma !) = gamma ?

And extend it to words, so that every trace t has a dual trace /t.

--------------------------------------------------------------------------------
| Trace equivalence
--------------------------------------------------------------------------------

Traces(I, LT, E) =
  let (LE, _) = E in
  let Init =
    if 0 in dom(LE) then
      let { M1; _; _ } = LT(0) in
      let code = M1 in
      PrgState ((0, 0), [], LT, code, I)
    else
      CtxState (     /,  /, LT,    /, I)
  in
                                 t
  { t | exists State, E |- Init ==> State }

same_traces (I, LT, E) (I', LT', E') ::=
  Traces(I, LT, E) = Traces(I', LT', E')

--------------------------------------------------------------------------------
| Mergeable states
--------------------------------------------------------------------------------

State  = PrgState (RF, GSP, LT,  code,  I, status)
State' = CtxState (/,  GSC, LT',    /, I', status)
|- linkable (I, LT, E) (I', LT', E')
|- compatible_views GSP GSC
--------------------------------------------------
E; E' |- mergeable State State'


E'; E |- mergeable State' State
------------------------------- SYM
E; E' |- mergeable State State'


-------------------------
|- compatible_views [] []


GSP = _ :: GSC'
GSC = / :: GSP'
|- compatible_views_rec GSP' GSC'
---------------------------------
|- compatible_views GSP GSC


-----------------------------
|- compatible_views_rec [] []


GSP = ((lr, _, _) :: _) :: GSC'
GSC = lr :: GSP'
|- compatible_views_rec GSP' GSC
-------------------------------
|- compatible_views_rec GSP GSC

--------------------------------------------------------------------------------
| State merging
--------------------------------------------------------------------------------

merge (E, E', State, State') ::=
  match (State, State') with
  | PrgState (RF, GSP, LT,  code, I,  status),
    CtxState (/,  GSC, LT', /,    I', status) ->
      let (I'', LT'', E'') = (I, LT, E) /\/\ (I', LT', E') in
      (I'', (RF, merge GSP GSC, LT'', code), E'')
  | CtxState _, PrgState _ ->
      merge State' State
   when E; E' |- mergeable State State'.

merge GSP GSC ::=
  match (GSP, GSC) with
  | [], [] -> []
  | GS :: GSC',
    _  :: GSP' ->
      GS ++ merge GSP' GSC'

  when |- compatible_views GSP GSC

--------------------------------------------------------------------------------
| Trace composition lemma
--------------------------------------------------------------------------------

forall E E1 E2 State1 State2 s t State'1 State'2,

if E1; E2 |- mergeable State1 State2

   /\ ((empty_map, empty_map), s, E, status) = merge (E1, E2, State1, State2)

                    t
   /\ E1 |- State1 ==> State'1

                   /t
   /\ E2 |- State2 ==> State'2

then |- mergeable State'1 State'2

     /\ exists s',

          ((empty_map, empty_map), s', E, _) = merge (E1, E2, State'1, State'2)

          /\ s -->*_E s'

--------------------------------------------------------------------------------
| Trace decomposition lemma
--------------------------------------------------------------------------------

forall E E1 E2 State1 State2 s s' status,

if E1; E2 |- mergeable State1 State2

   /\ ((empty_map, empty_map), s, E, status) = merge (E1, E2, State1, State2)

   /\ s -->*_E s'

then exists t State'1 State'2 status',

                     t
       E1 |- State1 ==> State'1

                       /t
       /\ E2 |- State2 ==> State'2

       /\ |- mergeable State'1 State'2

       /\ ((empty_map, empty_map), s', E, status') =
            merge (E1, E2, State'1, State'2)

--------------------------------------------------------------------------------
| Trace turn
--------------------------------------------------------------------------------

trace_turn(empty_word, p) =
  let (_, _, E) = p in
  let (LE, _) = E in
  if 0 in dom(LE) then
    Prg
  else
    Ctx

trace_turn(t.a, p) =
  let prev = trace_turn(t, p) in
  match a with
  | gamma ? | gamma ! ->
      match prev with
      | Ctx -> Prg
      | Prg -> Ctx
  | _ -> prev

--------------------------------------------------------------------------------
| Definability lemma
--------------------------------------------------------------------------------
| forall t p,
|   t in Traces(p) ->
|     exists C, |- linkable p (compile C)
|                 /\
|               forall /u in Traces(compile C),
|                 u ends with a context action (gamma ?) ->
|                 u is a prefix of t
--------------------------------------------------------------------------------

Intuition: We can only constrain the actions that the context will
take, and hence only the traces that end with a context action,
i.e. those such that trace_turn(u, p) = Prg.

--------------------------------------------------------------------------------
| Trace semantics soundness
--------------------------------------------------------------------------------
| forall p q, Traces(p) = Traces(q) -> forall c, c[p] ~ c[q]
--------------------------------------------------------------------------------

Proof:

Let p, q be low-level programs such that Traces(p) = Traces(q).

Lemma: Traces(p) = Traces(q) -> same_interface p q.

Let c be a low-level context linkable with both p and q.

Assume that c[p] terminates without getting stuck. We will show that
c[q] terminates without getting stuck as well. Symmetrically, when
c[q] terminates without getting stuck, so does c[p]. Hence, c[p] and
c[q] are observationnally equivalent for termination (QED).


Proof that c[q] terminates without getting stuck:

{
  Let (I_pq, LT_p, E_pq) = p,      p and q share I, E since they are
      (I_pq, LT_q, E_pq) = q,      interface equivalent
      (I_c, LT_c, E_c) = c.

  Let (LE_pq, OE_pq) = E_pq.

  Let (State_p, State_c) =
        if 0 in dom(OE_pq) then
          let { M1; _; _ } = LT_p(0) in
          let code = M1 in
          (PrgState ((0, 0), [], LT_p, code, Running),
           CtxState (     /,  /, LT_c,    /, Running))
        else
          let { M1; _; _ } = LT_c(0) in
          let code = M1 in
          (CtxState (     /,  /, LT_p,    /, Running),
           PrgState ((0, 0), [], LT_c, code, Running)).

  Let ((empty_map, empty_map), LT_cp, E) = c[p].

  Let s_cp =
    let LT_cp(0) = { M1; _; _ } in
    let code = M1 in
    ((0, 0), [], LT_cp, code).

  Lemma: E_pq; E_c |- mergeable State_p State_c
           /\
         ((empty_map, empty_map), s_cp, E, Running) =
           merge (E_pq, E_c, State_p, State_c)

  By hypothesis (termination of c[p])
    s_cp -->*_E s'_cp
  with
    s'_cp = ((0, 0), [], LT', Return :: _).

  We can hence apply the trace decomposition lemma to get
    t, State'_p, State'_c, status'
  such that

                        t
       E_pq |- State_p ==> State'_p

                         /t
       /\ E_c |- State_c ==> State'_c

       /\ |- mergeable State'_p State'_c

       /\ ((empty_map, empty_map), s'_cp, E, status') =
            merge (E_pq, E_c, State'_p, State'_c)

  We can wlog assume that status' = Done and that t ends with a tick
  (if it is not already the case, because of the shape of s'_cp we can
  extend t with a tick and get a Done status).

  Now, because Traces(p) = Traces(q), there must be a State'_q such
  that

                        t
       E_pq |- State_q ==> State'_q

  Lemma: same_interfaces p q ->
         |- mergeable State_p State_c ->
         |- mergeable State_q State_c

  Let ((empty_map, empty_map), LT_cq, E) = c[q].

  Let s_cq =
    let LT_cq(0) = { M1; _; _ } in
    let code = M1 in
    ((0, 0), [], LT_cq, code).

  We can now apply trace composition knowing that

       E_pq; E_c |- mergeable State_q State_c

       ((empty_map, empty_map), s_cq, E, status) =
         merge (E_pq, E_c, State_q, State_c)

                        t
       E_pq |- State_q ==> State'_q

                      /t
       E_c |- State_c ==> State'_c

  to get that

       |- mergeable State'_q State'_c
  and
       exists s'_cq,

          ((empty_map, empty_map), s'_cq, E, _) =
            merge (E_pq, E_c, State'_q, State'_c)

          /\ s_cq -->*_E s'_cq.

  Finally, because t ends with a tick, we know from the TICK! rule
  that:

    s'_cq = ((0, 0), [], LT'_cq, Return :: _)
    E = (LE, OE)
    LE(0) = class decl { 0 (0) } 
    OE(0) = obj decl 0
    LT_cq(l) = { M1, ..., Mp; OLT; o :: [] }
    OE(o) = obj decl 0

  Thus, we can conclude that:

    E |- LT_cq ==> o
}


--------------------------------------------------------------------------------
| Trace semantics completeness wrt high-level programs (requires exit)
--------------------------------------------------------------------------------
| forall P Q, (forall C, C[P] ~ C[Q]) -> Traces(compile P) = Traces(compile Q)
--------------------------------------------------------------------------------

Let P Q be programs such that (forall C, C[P] ~ C[Q]).

Let t be a trace in Traces(compile P).

Goal: t in Traces(compile Q).

Case: trace_turn(t, compile P) = Ctx.

Extend t with an observable action taken by the context : a tick.
The extended trace t' is still in Traces(compile P).

Apply the definability lemma to get a C such that

   |- linkable (compile C) (compile P)

   forall /u in Traces(compile C),
     trace_turn(u, p) = Prg ->
       u is a prefix of t

Hence (lemma about compilation and linkability)

   |- linkable C P

Hence (same_interface P Q)

   |- linkable C Q

By hypothesis,

   same_behaviors C[P] C[Q]

By compiler correctness/completeness + separate compilation,

   same_behaviors (compile C)[compile P] C[P]

   same_behaviors C[Q] (compile C)[compile Q]

Hence (transitivity)

   same_behaviors (compile C)[compile P] (compile C)[compile Q]

We can thus run program (compile C)[compile Q] until the expected
behavior appears.

   s -->* s'

   where s = (compile C)[compile Q]

Now apply trace decomposition to get a trace u such that

   /u in Traces(compile C)

   u in Traces(compile Q)

   s' = c'[q']

Thus u in Traces(compile Q), but since s' exhibits termination
behavior, u ends with a tick (or can be extended to end with a
tick). But it's also a prefix of t', and the only prefix of t' that
ends with a tick is t' itself. So t' is in Traces(compile Q) which
also implies that t in Traces(compile Q) by prefix-closedness.

================================================================================
| Symbolic micro-policy (compartmentalization variant)
================================================================================

Many differences with respect to Oakland 2015 policy:
  - Simplifications:
    - static compartments, no way to split things
    - no jump and write targets
      (just a way for all compartments to call all monitor services)
  - Extensions:
    - prohibiting all intra-compartment reads
    - protected call stack in monitor space
    - monitor services for call, return, and select
  - Differences:
    - monitor services that return in a different compartment (call and return)

--------------------------------------------------------------------------------
| Symbolic tags
--------------------------------------------------------------------------------

Tm  ::= c | _|_         once we have allocation, _|_ would be unallocated space
Tr  ::= ()
Tpc ::= c            Q: do we need to switch to <F,c> where F in {Jal,NoJal}?
Ts  ::= ()

--------------------------------------------------------------------------------
| Symbolic rules
--------------------------------------------------------------------------------

Nop: {tpc=c, tci=c} -> {tpc'=c}

Const: {tpc=c, tci=c} -> {tpc'=c, trd'=()}

Mov: {tpc=c, tci=c, trs=(), trd=()} -> {tpc'=c, trd'=()}

Binop: {tpc=c, tci=c, tr1=(), tr2=()} -> {tpc'=c, trd'=()}

Load: {tpc=c, tci=c, trp=(), tm=c, trd=()} -> {tpc'=c, trd'=()}

Store: {tpc=c, tci=c, trp=(), trs=(), tm=c} -> {tpc'=c, tm'=c}

Jump: {tpc=c, tci=c, tr=()} -> {tpc'=c}

Jal: {tpc=c, tci=c, tr=(), tra=()} -> {tpc'=c, tra=()}

Bnz: {tpc=c, tci=c, tr=()} -> {tpc'=c}

Service: {tpc=c, tci=()} -> {}

--------------------------------------------------------------------------------
| Extra state
--------------------------------------------------------------------------------

call_stack : list (word, word, word)

lookup_method : obj -> nat -> option addr

lookup_field : obj -> nat -> option addr

--------------------------------------------------------------------------------
| Monitor services
--------------------------------------------------------------------------------

call(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  let o = reg[r_arg1] in
  let arg = reg[r_arg2] in
  let m = reg[r_arg3] in
  ma <- lookup_method o m;
  if tag mem[reg[ra]] = c then
    let call_stack' = (reg[ra], reg[r_this], reg[r_arg]) :: call_stack in
    let reg' = (clear_registers reg)[r_this := o, r_arg := arg] in
    let c' = mem[ma] in
    Some (mem, reg', ma@c', (call_stack', lookup_method, lookup_field))
  else None

return(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  match call_stack with
  | (ret, this, arg) :: call_stack' ->
    let reg' = (clear_registers reg)[r_ret := reg[r_ret],
                                     r_this := this, r_arg := arg] in
    let c' = mem[ret] in
    Some (mem, reg', ret@c', (call_stack', lookup_method, lookup_field))
  | [] -> None

  is this useful??
    |   if we remove it, then lookup_field shouldn't be extra state,
    |   we should have a fixed scheme instead
    v

select(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  let o = reg[r_arg1] in
  let f = reg[r_arg2] in
  fa <- lookup_field o f;
  if tag mem[fa] = c then      <---- private fields
    let reg' = reg[r_ret := (val mem[fa])@()] in
    Some (mem, reg', ra@c, (call_stack, lookup_method, lookup_field))
  else
    None

Note: allowing returns to forged ra addresses seem ok because:
- for call we enforce that ra points to the caller's compartment
  - alternatively, we could store the caller's compartment on the call
    stack and restore it on return
- for select we preserve the same compartment id, so if the original
  value of ra was outside the compartment, the machine will stop on
  the next instruction fetch
- generally, our impression is that a return to an arbitrary place in
  the malicious component that invoked the service doesn't give the
  attacker additional power (the malicious component can already jump
  to any of its addresses); making this intuition formal in the full
  abstraction proof might be hard (or impossible if the intuition
  happens to be wrong), in which case we should require that monitor
  services are only reached via Jal


================================================================================
| Compilation scheme (old)
================================================================================

Define for each class:

  fieldoffset(l, f)
  methodoffset(l, m)

--------------------------------------------------------------------------------

Monitor services in the abstract machine:

* the idea: one stack per component ;
* two design choices:
    - a global stack handled by the monitor ;
    - or each stack located within the compartment of the component ;
* here: abstract machine, so we can manage them in the state for the moment.

/!\ need to forbid Jump-ing between compartements (e.g. for calling monitor services)
    --> only Jal
    (otherwise, we don't know who did the call, r_a may have been maliciously set by the attacker
     e.g. the stack of a component could be compromised by calling PUSH)

reg[r_arg1] = w
reg[r_a] = pc'
pc' in l_i
pc' - 1 in l_i                                   forbid jumps between distinct compartments
-----------------------------------------------------------------------------------------------
(mem, reg, push_addr, s_1, ..., s_i, ..., s_n) -> (mem, reg, pc', s_1, ..., w :: s_i, ..., s_n)

pc' in l_i
pc' - 1 in l_i                                   forbid jumps between distinct compartments
reg' = reg[r_ret <- w]
----------------------------------------------------------------------------------------------
(mem, reg, pop_addr, s_1, ..., w :: s_i, ..., s_n) -> (mem, reg', pc', s1, ..., s_i, ..., s_n)

mem[pc] = i
decode i = CALL rc rm ro rp
reg[rc] = c
reg[rm] = m
reg[ro] = o
reg[rp] = p

----------------------------
(mem, reg, pc, s) -> (mem, reg', pc', s)

mem[pc] = i
decode i = 
??
---------------
??

mem[pc] = i
decode[i] = Get ro rd
??
-----------------------
??

--------------------------------------------------------------------------------

Compilation of well-typed expressions:
  Variant #1: - doing everything via system calls
              - protection via compartmentalization micro-policy

Fix four distinct registers: r_this, r_arg, r_arg1, r_arg2, r_arg3, r_res (=r_ret), r_aux.

G = {this:lr, arg:la} when compiling a method body.
G = {} when compiling the main expression.

Properties of comp_expr:
- invariant: r_arg and r_this are preserved
            (they can change internally, but are restored at the end)
- can overwrite all other registers
- writes result to r_res
- finishes with same stack as it was called (restores the original stack)

comp_expr(this) = Mov r_this r_res
  (G(this) is defined in this case)

comp_expr(arg) = Mov r_arg r_res
  (G(arg) is defined in this case)

comp_expr(o) = Const o r_res

comp_expr(e.f) =
    comp_expr(e);
    Mov r_res r_arg1;
    Cons i_f r_arg2;
    Jal SELECT
  if G |- e : l (deterministic)
  and i_f = fieldoffset(l, f)

comp_expr(e.m(e')) =
    comp_expr(e);
    Jal PUSH r_res;
    comp_expr(e');
    Pop r_arg1;
    Mov r_res r_arg2;
    Const i_m r_arg3;
    Push r_this;
    Push r_arg;
    Jal CALL
    Pop r_arg;
    Pop r_this
  if G |- e : l (deterministic)
  and i_m = methodoffset(l, m)

comp_expr(e1 == e2 ? e3 : e4) =
    comp_expr(e1);
    Push r_res;
    comp_expr(e2);
    Pop r_aux;
    Binop_= r_aux r_res r_aux;
    Bnz r_aux LST;
    comp_expr(e4);
    Jump END;
LST:comp_expr(e3);
END:Nop

Q: How to represent the auxiliary stack of saved registers?
- globally, accessed via system calls
  - could be merged with global call stack:
    - stack frames between return addresses
    - Pop can't affect return addresses, only Return can
- locally, each compartment keeps its own stack
  - would work well with all alts below

--------------------------------------------------------------------------------

  Variant #2: - everything directly via instructions
                - monitor call only for index_to_addr (later object allocation)
              - fine-grained micro-policy
              - TODO: still unclear what to do with the stack(s)
                - alt1: keep using monitor service for call stack
                - alt2: protected call stack outside the monitor
                        (micro-policy for call-stack protection)
                - alt3: lightweight return addr protection + only local stacks

comp_expr(e.f) =
    comp_expr(e);
    Const a r_aux;
    Binop_+ r_res r_aux r_aux;
    Load r_aux r_res
  if G |- e : l (deterministic)
  and a = fieldoffset(l, f)

comp_expr(e.m(e')) =
    comp_expr(e);
    Push r_res;
    comp_expr(e');
    Pop r_aux;
    Push r_this;
    Push r_arg;
    Mov r_aux r_this;
    Mov r_res r_arg;
    Const a r_aux;
    Jal r_aux;
    Pop r_arg;
    Pop r_this
  if G |- e : l (deterministic)
  and a = ClassAdressTable(l) + methodoffset(l, m)

comp_expr(e1 == e2 ? e3 : e4) =
    comp_expr(e1);
    Push r_res;
    comp_expr(e2);
    Pop r_aux;
    Binop_- r_aux r_res r_aux;
    Bnz r_aux k;
    comp_expr(e3);
    Const 1 r_aux;                        } ugly relative jump
    Bnz k' r_aux;                         } ^^^^^^^^^^^^^^^^^^
    comp_expr(e4)
  if k = |comp_expr(e3)| + 2
  and k' = |comp_expr(e4)|
