================================================================================
| Syntax
================================================================================

What we call names hereafter are naturals. When compiling to a
realistic architecture, we will require them to be word-sized.

l - class name -- mapped to class declarations L (LT)
f - field index (natural)
m - method index (natural)
o - object names -- mapped to object declarations O (OT)

--------------------------------------------------------------------------------
| Programs
--------------------------------------------------------------------------------

A ::= (LT, OT)                   program

LT ::= partial map from l to L   class table

OT ::= partial map from o to O   object table

L ::=
  class {                        class definition
    l1, ..., ln;                   field declarations
    M1, ..., Mp                    method definitions
  }
  where n, p >= 0

O ::=
  obj l { o1, ..., on }          object definition
  where n >= 0

M ::=                            method declaration
  lr (la) {                        result and argument types
    e                              method body
  }

x ::=
  | this                         object on which the method was called
  | arg                          object the method was provided as argument

e ::=                            expressions
  | x                              variables
  | o                              object reference
  | e.f                            field selection
  | e.m(e)                         method call
  | e == e ? e : e                 object identity test

--------------------------------------------------------------------------------
| Partial programs
--------------------------------------------------------------------------------

P ::= (                          partial program
  D,                               declarations
  A                                definitions (syntactically like a
                                   program defined above)
)

D ::= (ST, IT)

ST ::= partial map from l to S   signature table (class declaration table)

IT ::= partial map from o to I   instance table (object declaration table)

S ::=
  class sig {                    class declaration
    N1, ..., Np                    method signatures
  }
  where p >= 0

I ::=
  obj sig l                      object declaration

N ::=
  lr (la)

--------------------------------------------------------------------------------
| Programs are partial programs in disguise
--------------------------------------------------------------------------------

Every program A = (LT, OT) can (and will) be seen as a partial program
(D, A) where

  D = (ST, IT)

  ST : dom(LT)                     -> S
       class {                        class sig {
         ...;                     |->   meth_sig(M1), ..., meth_sig(Mp)
         M1, ..., Mp                  }
       }

  meth_sig : M              -> N
             lr (la) { e } |-> lr (la)

  ST : dom(LT)       -> I
       obj l { ... } |-> obj sig l

================================================================================
| Operational semantics
================================================================================

--------------------------------------------------------------------------------
| Def.: Reduction relation on expressions.
--------------------------------------------------------------------------------

----------------------- REFL
A; (ot, oa) |- e -->* e


A; (ot, oa) |- e --> e'
A; (ot, oa) |- e' -->* e''
-------------------------- STEP
A; (ot, oa) |- e -->* e''


-------------------------- THIS
A; (ot, oa) |- this --> ot


------------------------- ARG
A; (ot, oa) |- arg --> oa


A = (OT, LT)
OT(ot) = obj l { ... }               field privacy (granularity: class)
OT(o) = obj l { o1, ..., on }
f = i in [1,n]
----------------------------- SEL
A; (ot, oa) |- o.f --> oi


A = (OT, LT)
OT(ot') = obj l { o1, ..., on }
LT(l) = class { ... ; M1, ..., Mp }
Mj = lr (la) { e }
m = j in [1,p]
A; (ot', oa') |- e -->* o
----------------------------------- CALL
A; (ot, oa) |- ot'.m(oa') --> o


------------------------------------ TESTEQ
A; (ot, oa) |- o == o ? e : e' --> e


o <> o'
-------------------------------------- TESTNEQ
A; (ot, oa) |- o == o' ? e : e' --> e'


A; (ot, oa) |- e1 --> e1'
--------------------------------------- CONGRLCALL
A; (ot, oa) |- e1.mi(e2) --> e1'.mi(e2)


A; (ot, oa) |- e --> e'
----------------------------------- CONGRRCALL
A; (ot, oa) |- o.mi(e) --> o.mi(e')


A; (ot, oa) |- e1 --> e1'
--------------------------------------------------------- CONGRLTEST
A; (ot, oa) |- e1 == e2 ? e3 : e4 --> e1' == e2 ? e3 : e4


A; (ot, oa) |- e2 --> e2'
------------------------------------------------------- CONGRRTEST
A; (ot, oa) |- o == e2 ? e3 : e4 --> o == e2' ? e3 : e4


We sometimes use the notation e --> e', where A, ot and oa are
implicitly assumed.

--------------------------------------------------------------------------------
| Def.: Values
--------------------------------------------------------------------------------

A value is an object name.

--------------------------------------------------------------------------------
| Prop.: Values do not reduce
--------------------------------------------------------------------------------
| forall (v:value) (e: expr), v -/-> e.
--------------------------------------------------------------------------------

Proof: No rule applies when we have an object name in the left hand side.

--------------------------------------------------------------------------------
| Prop.: Equality on values is decidable
--------------------------------------------------------------------------------
| forall v v', {v = v'} + {v <> v'}.
--------------------------------------------------------------------------------

Proof: Object names are naturals.

--------------------------------------------------------------------------------
| Prop.: Determinism of our reduction relation
--------------------------------------------------------------------------------
| forall e e' e'',
|    e --> e'  ->
|    e --> e'' ->
|      e' = e''
--------------------------------------------------------------------------------

Proof: Corollary of the fact that values (hence object names) do not
reduce.

By induction on the size of the derivation tree for e --> e'. By case
on the last rule applied in this tree. Only this rule applies with e
as a the left-hand side, because object names do not reduce and
equality on values is decidable. This gives the shape of e'', and is
sufficient to conclude in the base case. In the inductive case,
applying the induction hypothesis ends the proof.


================================================================================
| Type system
================================================================================

--------------------------------------------------------------------------------
| Def.: Partial-program typing
--------------------------------------------------------------------------------

P = (D, A)
D = (ST, IT)
A = (LT, OT)
dom(LT) subset of dom(ST)
forall l in dom(LT),
  let class { ...; M1, ..., Mp } = LT(L) in
  ST(l) = class sig { meth_sig(M1), ..., meth_sig(Mp) }
forall l in dom(LT),
  let obj l { ... } = OT(L) in
  IT(l) = obj sig l
dom(OT) subset of dom(IT)
forall l in dom(ST). P |- ST(l) ok
forall o in dom(IT). P |- IT(l) ok
forall l in dom(LT). P |- LT(l) @ l ok
forall o in dom(OT). P |- OT(l) ok
------------------------------------------------- PROGOK
|- P ok

This is the only place where we check that LT "implements" ST and
OT "implements" IT. The other rules often make no sense if it is not
the case, so it is an (explicit) assumption to make about P every time
we want to prove something interesting about the other rules.

--------------------------------------------------------------------------------
| Def.: Object declaration typing
--------------------------------------------------------------------------------

P = (D, _)
D = (ST, _)
l in dom(ST)
----------------- OBJSIGOK
P |- obj sig l ok

--------------------------------------------------------------------------------
| Def.: Object definition typing
--------------------------------------------------------------------------------

P = (D, A)
D = (_, IT)
A = (LT, _)
LT(l) = class { l1, ..., ln; ... }
forall i in [1,n]. IT(oi) = obj sig li
-------------------------------------- OBJOK
P |- obj l { o1, ..., on } ok

--------------------------------------------------------------------------------
| Def.: Class declaration typing
--------------------------------------------------------------------------------

P = (D, _)
D = (ST, _)
forall j in [1,p],
  let lr (la) = Si in
  lr in dom(ST) /\ la in dom(ST)
--------------------------------- CLASSSIGOK
P |- class sig { S1, ..., Sp } ok

--------------------------------------------------------------------------------
| Def.: Class definition typing
--------------------------------------------------------------------------------

P = (D, _)
D = (ST, _)
forall i in [1,n]. li in dom(ST)
forall j in [1,p]. P |- Mj @ lt ok
----------------------------------------------- CLASSOK
P |- class { l1, ..., ln; M1, ..., Mp } @ lt ok

--------------------------------------------------------------------------------
| Def.: Method typing
--------------------------------------------------------------------------------

G = {this:lt, arg:la}
P; G |- e : lr
-------------------------- METHOK
P |- lr (la) { e } @ lt ok

--------------------------------------------------------------------------------
| Def.: Expression typing
--------------------------------------------------------------------------------

We define typing environments as:

                           G ::= {this:lt, arg:la}

---------------- TVAR
P; G |- x : G(x)

P = (D, _)
D = (_, IT)
IT(o) = obj sig l
----------------- TOBJ
P; G |- o : l

P; G |- e : l
G(this) = l                                   ensures field privacy
P = (_, A)
A = (LT, _)
LT(l) = class { l1, ..., ln; ... }
f = i in [1,n]
---------------------------------- TSEL
P; G |- e.f : li

P; G |- e : l
P = (D, _)
D = (ST, _)
ST(l) = class sig { S1, ..., Sp }
m = j in [1,p]
Sj = lr (la)
P; G |- ea : la
--------------------------------- TCALL
P; G |- e.m(ea) : lr

P; G |- e1 : l'
P; G |- e2 : l'
P; G |- e3 : l
P; G |- e4 : l
-------------------------------- TTEST
P; G |- (e1 == e2 ? e3 : e4) : l

================================================================================
| Encodings
================================================================================

--------------------------------------------------------------------------------
| Tuples
--------------------------------------------------------------------------------

For each tuple type T=(l1, ..., ln)

class Unit {}

obj tt : Unit {}

class Tuple_T {
  l1 f1, ..., ln fn;
  l1 get_1(Unit) { this.f1 },
  ...
  ln get_n(Unit) { this.fn },
}

--------------------------------------------------------------------------------
| Booleans
--------------------------------------------------------------------------------

class Bool {}

obj true : Bool {}
obj false : Bool {}

If then else via identity test (e.g. (b == true ? e1 : e2)).


================================================================================
| Properties of our type system
================================================================================

(To be proved)

--------------------------------------------------------------------------------
| Progress
--------------------------------------------------------------------------------
| forall e l P G, |- P ok ->
|                 P; G |- e : l ->
|                   is_value e \/ exists e', P |- e --> e'
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Preservation (Subject reduction)
--------------------------------------------------------------------------------
| forall e e' l P G, P; G |- e : l ->
|                    P |- e --> e' ->
|                      P; G |- e' : l
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Type safety
--------------------------------------------------------------------------------
| forall e l P G, P; G |- e : l ->
|                      is_value e \/ (exists e', e --> e' /\ |- e' : l)
--------------------------------------------------------------------------------


================================================================================
| High-level programs, high-level contexts
================================================================================

--------------------------------------------------------------------------------
| Def.: Compatibility
--------------------------------------------------------------------------------

Two well-typed partial programs are compatible if they share the same
declarations while having disjoint domains for their definitions, that
is:

  |- P ok
  |- P' ok
  P = (D, (LT, OT))
  P' = (D, (LT', OT'))
  dom(LT) inter dom(LT') = empty_set
  dom(OT) inter dom(OT') = empty_set
  -------------------------------------------
  |- P compatible P'

Note: Condition:
  dom(OT) inter dom(OT') = empty_set
is entailed by condition:
  dom(LT) inter dom(LT') = empty_set
since well-typed partial programs can only provide object definitions
for classes that they actually define. As such, it could be removed.

--------------------------------------------------------------------------------
| Def.: Linking
--------------------------------------------------------------------------------

Two compatible (partial) programs
  P = (D, (LT, OT))
  Q = (D, (LT', OT')) can
be linked to get a new (partial) program P /\/\ Q.

  P /\/\ Q ::= (D, (LT disjoint_union LT', OT disjoint_union OT'))

--------------------------------------------------------------------------------
| Def.: Complete programs (todo)
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
| Def.: Evaluable programs (todo)
--------------------------------------------------------------------------------

A program is evaluable if it is a complete program, that is compatible
with the following program:

  CT = (0 => class sig { 0 (0) })
  OT = (0 => obj sig 0)

--------------------------------------------------------------------------------
| Def.: Evaluation (todo)
--------------------------------------------------------------------------------

Given an evaluable program P = (LT, OT), one can show that reducing
the expression 0.0(0) in any context of the form (LT, OT, ot, oa)
yields the same result independently of the choice for ot and oa.

Hence, only programs that define object 0 with a class l such that l
has (at least) one method will have a non-stuck initial expression. This
will be part of the notion of complete programs in our type system.

--------------------------------------------------------------------------------
| Def.: High-level context (old)
--------------------------------------------------------------------------------

A high-level context c is a partial program. A program can only be
inserted in a linkable context. Inserting a program P in a context c
is linking:

     c[P] ::= P /\/\ c       when linkable c P

--------------------------------------------------------------------------------
| Def.: Closing contexts (old)
--------------------------------------------------------------------------------

Given a program P, a context c, a class name l, we say that c closes P
with type l when c is linkable with P and inserting P in c gives a
well-typed program of type l, that is:

                  linkable c P  /\  |- c[P] : l

We define the set of closing contexts at type l for a program P by:

     closing_contexts P l ::= {c | linkable c P  /\  |- c[P] : l}

--------------------------------------------------------------------------------
| Def.: Interface equivalence (old)
--------------------------------------------------------------------------------

We say that two programs P and Q are interface equivalent, or have the
same interface, when they have the same closing contexts at every
type, that is:

  same_interface P Q := forall l. closing_contexts P l = closing_contexts Q l

--------------------------------------------------------------------------------
| Def.: Observational equivalence (old)
--------------------------------------------------------------------------------

Two programs P and Q are observationnally equivalent if they are
interface equivalent and, for any context c that closes them, when
separately placing the two in c, the two resulting programs reduce to
the same value. That is:

  P ~ Q ::= same_interface P Q /\
            forall l. forall c in closing_contexts P l. forall v.
            let o = 0 and m = 0 in
            c[P] |- o.m(o) -->* v  <->  c[Q] |- o.m(o) -->* v

--------------------------------------------------------------------------------
| Def.: Observational order (old)
--------------------------------------------------------------------------------

We define the observational order on programs as follows:

  P ~< Q ::=
    forall l. forall c in closing_contexts P l.
    c in closing_contexts Q l /\ forall v.
                                 let o = 0 and m = 0 in
                                 c[P] |- o.m(o) -->* v  ->
                                   c[Q] |- o.m(o) -->* v

When we have P ~< Q, this means that Q captures all the behaviors of P.

--------------------------------------------------------------------------------
| Prop.: Decomposition of observational equivalence
--------------------------------------------------------------------------------
| forall P Q. P ~ Q <-> (P ~< Q and Q ~< P)
--------------------------------------------------------------------------------

================================================================================
| "Really abstract" intermediate machine
================================================================================

Here we present an abstract machine. The goal is to have an
intermediate language which offers a lower-level view, while still
being abstract (e.g. we allow unbounded stacks).

--------------------------------------------------------------------------------
| Informal overview
--------------------------------------------------------------------------------

A machine state is formed by:

* the currently running code;

* two read-only registers, this and arg, one holding a reference to
  the current object, the other holding a reference to the current
  argument;

* a call stack that will allow storing the current environment before
  performing a call, so that it can be restored afterwards;

* compartments, each corresponding to a high-level class, storing the
  code for its methods, all its instances, and a local
  stack used when executing a method of this compartment.

The running code can only use (i.e. pop from / push to) the local
stack owned by the class of the object that is currently referenced by
register this. Upon call, we may switch compartments, and thus local
stacks.

This prevents low-level methods from compromising the local stack used by a
caller of a different compartment. An attacker compromising a given
class won't be able to damage an uncompromised caller's user stack
before control gets back to this caller.

--------------------------------------------------------------------------------
| Syntax
--------------------------------------------------------------------------------

At this level only compartments have names. Objects are indexed
compartement-wise.

l ::= n                    compartment name (where n is natural)
o ::= n                    object index (where n is natural)
f ::= n                    field index (where n is natural)
m ::= n                    method index (where n is natural)

r ::= (l, o)               object reference

s ::= (                    machine state
  RF,                        a register file
  GS,                        a global call stack
  LT,                        compartments table
  code                       the running code
)

RF ::= (                   register file of immutable registers
  this => r,                 current instance
  arg => r                   current argument
)

GS ::= [] | (              call stack: to restore execution after a call
  RF,                        register file to be restored
  code                       code to be executed (will pop the result
                             value from the local stack)
) :: GS

LT ::= partial map from l to L

L ::= {                    compartment
  M1, ..., Mp;               methods
  O1, ..., Oq;               instances
  LS                         local stack
}

  where p, q >= 0

O ::= (r1, ..., rn)        object

  where n >= 0

M ::=                      method
  code

LS ::=                     local stack storing object references
  [] | r :: local_stack

code ::=                   code
  [] | instr :: code         list of instructions


Note: "stack" always means "current local stack" when describing an
instruction hereafter, similarly "push" and "pop" always refer to
operations on the current local stack.


instr ::=                  instruction
  | Nop
  | This                     push reg[this]
  | Arg                      push reg[arg]
  | Ref r                    push reference r
  | Dup                      duplicate top value
  | Select f                 field selection
                               pop, then push the value of field f of
                               the popped object
  | Call m                   method call
                               pop twice, then call method m of the
                               first popped object, using the second
                               popped object as argument
  | Return                   return from call (with result)
                               pop, then resume execution to the
			       caller after pushing popped value to
			       its local stack
  | Beq n                    object identity test
                               pop twice, then skip n instructions
			       (forward jump) if the two references
			       refer to the same object

Note: At this level we make no distinction between inter- and intra-
compartment calls. If we were to need this distinction it would anyway
be lower level.

Note: Now we actually have two rules for inter and intra, but they
could be merged into one, following the intuition described
above. They look cleaner when separated (otherwise we would be popping
a value, then pushing it again to the very same stack, which looks a
bit silly; the rule would also be longer to state).

--------------------------------------------------------------------------------
| Def.: Reduction
--------------------------------------------------------------------------------

Macro:

  PointsToSomething(r) ::=
    r = (l, o)
    LT(l) = { ...; O1, ..., Oq; ... }
    o <= q

TODO: Add sanity checks in the rules, which should hopefully be
*proved* useless e.g. because they are invariants. Having them around
when stating the rules looks good. Is this a good idea? Would it be
too strong to add everywhere the following premisse?

    PointsToSomething(RF(this))
    PointsToSomething(RF(arg))
    forall l in dom(LT),
      match LT(l) with
      | { ...; ...; LS} =>
            for every r in LS,
            PointsToSomething(r)

Rules:

  ----------------------------------------------- NOP
  (RF, GS, LT, Nop :: code) -> (RF, GS, LT, code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; r :: LS }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; r :: r :: LS }
  ------------------------------------------------------------- DUP
  (RF, GS, LT, Dup :: code) -> (RF, GS, LT', code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; LS }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; r :: LS }
  -------------------------------------------------------- REF
  (RF, GS, LT, Ref r :: code) -> (RF, GS, LT', code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; LS }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; RF(this) :: LS }
  --------------------------------------------------------------- THIS
  (RF, GS, LT, This :: code) -> (RF, GS, LT', code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; LS }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; RF(arg) :: LS }
  -------------------------------------------------------------- ARG
  (RF, GS, LT, Arg :: code) -> (RF, GS, LT', code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; r :: LS }
  r = (l, o)          requiring l here ensures field privacy
  Oo = (r1, ..., rn)
  f <= n
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; rf :: LS }
  --------------------------------------------------------- SELECT
  (RF, GS, LT, Select f :: code) -> (RF, GS, LT', code)

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; ra :: rt :: LS }
  rt = (l', _)
  LT(l') = { M'1, ..., M'p'; ...; _ }
  m <= p'
  M'm = code'
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; LS }
  GS' = (RF, code) :: GS
  RF' = (this => rt, arg => ra)
  ------------------------------------------------------ CALL
  (RF, GS, LT, Call m :: code) -> (RF', GS', LT', code')

  GS = (RF', code') :: GS'
  RF(this) = (l, _)
  RF'(this) = (l', _)
  l <> l'
  LT(l) = { M1, ..., Mp; O1, ..., Oq; rr :: LS }
  LT(l') = { M'1, ..., M'p; O'1, ..., O'q; LS' }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; LS }
                l' => { M'1, ..., M'p; O'1, ..., O'q; rr :: LS }
  -------------------------------------------------------------- RETURN-INTER
  (RF, GS, LT, Return :: code) -> (RF', GS', LT', code')

  GS = (RF', code') :: GS'
  RF(this) = (l, _)
  RF'(this) = (l, _)
  ------------------------------------------------------ RETURN-INTRA
  (RF, GS, LT, Return :: code) -> (RF', GS', LT, code')


  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; r :: r :: LS }
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; LS }
  code = i1 :: ... :: in :: code'
  --------------------------------------------------- BEQ-EQ
  (RF, GS, LT, Beq n :: code) -> (RF, GS, LT', code')

  RF(this) = (l, _)
  LT(l) = { M1, ..., Mp; O1, ..., Oq; r1 :: r2 :: LS }
  r1 <> r2
  LT' = LT with l => { M1, ..., Mp; O1, ..., Oq; LS }
  ---------------------------------------------------- BEQ-NEQ
  (RF, GS, LT, Beq n :: code) -> (RF, GS, LT', code)


--------------------------------------------------------------------------------
| Def.: Compilation of expressions
--------------------------------------------------------------------------------

Define:

  obj_id(LT, OT, o_high) = (l_low, o_low)
    if OT(o_high) = obj l_high { ... }
    and l_high in dom(LT)
    and l_low = l_high
    and o_low = ||{o'_high in dom(OT) |
                   OT(o_high) = obj l { ... } and
                   o'_high < o_high}||

Invariant:

  after the whole execution of the code for c_expr(LT, OT, e), the
  compartment is the same as before, and exactly one new object
  reference has been pushed on the local stack.

  This reference is obj_id(v) iff (LT, OT) |- e -->* v.

Compilation:

  c_expr(LT, OT, this) = This

  c_expr(LT, OT, arg) = Arg

  c_expr(LT, OT, o) = Ref obj_id(LT, OT, o)

  c_expr(LT, OT, e.f) =
     c_expr(LT, OT, e);
     Select f

  c_expr(LT, OT, e.m(e')) =
     c_expr(LT, OT, e);
     c_expr(LT, OT, e');
     Call m

  c_expr(LT, OT, e1 == e2 ? e3 : e4) =
     c_expr(LT, OT, e1);
     c_expr(LT, OT, e2);
     Beq EQ;       (note: these are indeed relative forward jumps, so this works)
     c_expr(LT, OT, e4);
     Dup;          }  <--- a way to encode unconditional forward jump
     Beq END;      }
EQ:  c_expr(LT, OT, e3);
END: Nop

--------------------------------------------------------------------------------
| Def.: Compilation of (complete) programs (old)
--------------------------------------------------------------------------------

Compiling a complete program is quite straightforward once we know how
to compile expressions. We can get a list of classes out of LT by
skipping "holes" in the domain, and a list of objects for each class
by skipping "holes" in the domain and using one counter per class.


================================================================================
| Symbolic micro-policy (compartmentalization variant)
================================================================================

Many differences with respect to Oakland 2015 policy:
  - Simplifications:
    - static compartments, no way to split things
    - no jump and write targets
      (just a way for all compartments to call all monitor services)
  - Extensions:
    - prohibiting all intra-compartment reads
    - protected call stack in monitor space
    - monitor services for call, return, and select
  - Differences:
    - monitor services that return in a different compartment (call and return)

--------------------------------------------------------------------------------
| Symbolic tags
--------------------------------------------------------------------------------

Tm  ::= c | _|_         once we have allocation, _|_ would be unallocated space
Tr  ::= ()
Tpc ::= c            Q: do we need to switch to <F,c> where F in {Jal,NoJal}?
Ts  ::= ()

--------------------------------------------------------------------------------
| Symbolic rules
--------------------------------------------------------------------------------

Nop: {tpc=c, tci=c} -> {tpc'=c}

Const: {tpc=c, tci=c} -> {tpc'=c, trd'=()}

Mov: {tpc=c, tci=c, trs=(), trd=()} -> {tpc'=c, trd'=()}

Binop: {tpc=c, tci=c, tr1=(), tr2=()} -> {tpc'=c, trd'=()}

Load: {tpc=c, tci=c, trp=(), tm=c, trd=()} -> {tpc'=c, trd'=()}

Store: {tpc=c, tci=c, trp=(), trs=(), tm=c} -> {tpc'=c, tm'=c}

Jump: {tpc=c, tci=c, tr=()} -> {tpc'=c}

Jal: {tpc=c, tci=c, tr=(), tra=()} -> {tpc'=c, tra=()}

Bnz: {tpc=c, tci=c, tr=()} -> {tpc'=c}

Service: {tpc=c, tci=()} -> {}

--------------------------------------------------------------------------------
| Extra state
--------------------------------------------------------------------------------

call_stack : list (word, word, word)

lookup_method : obj -> nat -> option addr

lookup_field : obj -> nat -> option addr

--------------------------------------------------------------------------------
| Monitor services
--------------------------------------------------------------------------------

call(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  let o = reg[r_arg1] in
  let arg = reg[r_arg2] in
  let m = reg[r_arg3] in
  ma <- lookup_method o m;
  if tag mem[reg[ra]] = c then
    let call_stack' = (reg[ra], reg[r_this], reg[r_arg]) :: call_stack in
    let reg' = (clear_registers reg)[r_this := o, r_arg := arg] in
    let c' = mem[ma] in
    Some (mem, reg', ma@c', (call_stack', lookup_method, lookup_field))
  else None

return(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  match call_stack with
  | (ret, this, arg) :: call_stack' ->
    let reg' = (clear_registers reg)[r_ret := reg[r_ret],
                                     r_this := this, r_arg := arg] in
    let c' = mem[ret] in
    Some (mem, reg', ret@c', (call_stack', lookup_method, lookup_field))
  | [] -> None

  is this useful??
    |   if we remove it, then lookup_field shouldn't be extra state,
    |   we should have a fixed scheme instead
    v

select(mem, reg, pc@c, (call_stack, lookup_method, lookup_field)) =
  let o = reg[r_arg1] in
  let f = reg[r_arg2] in
  fa <- lookup_field o f;
  if tag mem[fa] = c then      <---- private fields
    let reg' = reg[r_ret := (val mem[fa])@()] in
    Some (mem, reg', ra@c, (call_stack, lookup_method, lookup_field))
  else
    None

Note: allowing returns to forged ra addresses seem ok because:
- for call we enforce that ra points to the caller's compartment
  - alternatively, we could store the caller's compartment on the call
    stack and restore it on return
- for select we preserve the same compartment id, so if the original
  value of ra was outside the compartment, the machine will stop on
  the next instruction fetch
- generally, our impression is that a return to an arbitrary place in
  the malicious component that invoked the service doesn't give the
  attacker additional power (the malicious component can already jump
  to any of its addresses); making this intuition formal in the full
  abstraction proof might be hard (or impossible if the intuition
  happens to be wrong), in which case we should require that monitor
  services are only reached via Jal


================================================================================
| Compilation scheme (old)
================================================================================

Define for each class:

  fieldoffset(l, f)
  methodoffset(l, m)

--------------------------------------------------------------------------------

Monitor services in the abstract machine:

* the idea: one stack per component ;
* two design choices:
    - a global stack handled by the monitor ;
    - or each stack located within the compartment of the component ;
* here: abstract machine, so we can manage them in the state for the moment.

/!\ need to forbid Jump-ing between compartements (e.g. for calling monitor services)
    --> only Jal
    (otherwise, we don't know who did the call, r_a may have been maliciously set by the attacker
     e.g. the stack of a component could be compromised by calling PUSH)

reg[r_arg1] = w
reg[r_a] = pc'
pc' in l_i
pc' - 1 in l_i                                   forbid jumps between distinct compartments
-----------------------------------------------------------------------------------------------
(mem, reg, push_addr, s_1, ..., s_i, ..., s_n) -> (mem, reg, pc', s_1, ..., w :: s_i, ..., s_n)

pc' in l_i
pc' - 1 in l_i                                   forbid jumps between distinct compartments
reg' = reg[r_ret <- w]
----------------------------------------------------------------------------------------------
(mem, reg, pop_addr, s_1, ..., w :: s_i, ..., s_n) -> (mem, reg', pc', s1, ..., s_i, ..., s_n)

mem[pc] = i
decode i = CALL rc rm ro rp
reg[rc] = c
reg[rm] = m
reg[ro] = o
reg[rp] = p

----------------------------
(mem, reg, pc, s) -> (mem, reg', pc', s)

mem[pc] = i
decode i = 
??
---------------
??

mem[pc] = i
decode[i] = Get ro rd
??
-----------------------
??

--------------------------------------------------------------------------------

Compilation of well-typed expressions:
  Variant #1: - doing everything via system calls
              - protection via compartmentalization micro-policy

Fix four distinct registers: r_this, r_arg, r_arg1, r_arg2, r_arg3, r_res (=r_ret), r_aux.

G = {this:lr, arg:la} when compiling a method body.
G = {} when compiling the main expression.

Properties of c_expr:
- invariant: r_arg and r_this are preserved
            (they can change internally, but are restored at the end)
- can overwrite all other registers
- writes result to r_res
- finishes with same stack as it was called (restores the original stack)

c_expr(this) = Mov r_this r_res
  (G(this) is defined in this case)

c_expr(arg) = Mov r_arg r_res
  (G(arg) is defined in this case)

c_expr(o) = Const o r_res

c_expr(e.f) =
    c_expr(e);
    Mov r_res r_arg1;
    Cons i_f r_arg2;
    Jal SELECT
  if G |- e : l (deterministic)
  and i_f = fieldoffset(l, f)

c_expr(e.m(e')) =
    c_expr(e);
    Jal PUSH r_res;
    c_expr(e');
    Pop r_arg1;
    Mov r_res r_arg2;
    Const i_m r_arg3;
    Push r_this;
    Push r_arg;
    Jal CALL
    Pop r_arg;
    Pop r_this
  if G |- e : l (deterministic)
  and i_m = methodoffset(l, m)

c_expr(e1 == e2 ? e3 : e4) =
    c_expr(e1);
    Push r_res;
    c_expr(e2);
    Pop r_aux;
    Binop_= r_aux r_res r_aux;
    Bnz r_aux LST;
    c_expr(e4);
    Jump END;
LST:c_expr(e3);
END:Nop

Q: How to represent the auxiliary stack of saved registers?
- globally, accessed via system calls
  - could be merged with global call stack:
    - stack frames between return addresses
    - Pop can't affect return addresses, only Return can
- locally, each compartment keeps its own stack
  - would work well with all alts below

--------------------------------------------------------------------------------

  Variant #2: - everything directly via instructions
                - monitor call only for index_to_addr (later object allocation)
              - fine-grained micro-policy
              - TODO: still unclear what to do with the stack(s)
                - alt1: keep using monitor service for call stack
                - alt2: protected call stack outside the monitor
                        (micro-policy for call-stack protection)
                - alt3: lightweight return addr protection + only local stacks

c_expr(e.f) =
    c_expr(e);
    Const a r_aux;
    Binop_+ r_res r_aux r_aux;
    Load r_aux r_res
  if G |- e : l (deterministic)
  and a = fieldoffset(l, f)

c_expr(e.m(e')) =
    c_expr(e);
    Push r_res;
    c_expr(e');
    Pop r_aux;
    Push r_this;
    Push r_arg;
    Mov r_aux r_this;
    Mov r_res r_arg;
    Const a r_aux;
    Jal r_aux;
    Pop r_arg;
    Pop r_this
  if G |- e : l (deterministic)
  and a = ClassAdressTable(l) + methodoffset(l, m)

c_expr(e1 == e2 ? e3 : e4) =
    c_expr(e1);
    Push r_res;
    c_expr(e2);
    Pop r_aux;
    Binop_- r_aux r_res r_aux;
    Bnz r_aux k;
    c_expr(e3);
    Const 1 r_aux;                        } ugly relative jump
    Bnz k' r_aux;                         } ^^^^^^^^^^^^^^^^^^
    c_expr(e4)
  if k = |c_expr(e3)| + 2
  and k' = |c_expr(e4)|
