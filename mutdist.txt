Interesting symbols for Unicode proofs: ∀∃∄∈∉≈∼⊢

⋈ is partial programs linking.

↓ is compilation.


Full abstraction
----------------

FA: ∀PQ, (∀A, A⋈P  ~H A⋈Q )
       ↔ (∀a, a⋈P↓ ~L a⋈Q↓).

Usual full abstraction relates *arbitrary* low-level distinguishers to
*arbitrary* high-level distinguishers. The intuition is that when full
abstraction holds:

* any attack in the high-level can be modeled as an attack in the
  low-level, i.e. there are no "false attacks" when we reason in the
  high-level;
* moreover, every attack in the low-level can be modeled as a
  high-level attack: we are not losing any low-level attack when we
  reason in the high-level.

Now what if, actually, the attacker cannot mount *any* attack but only
one that uses a fixed, known number of components? This is our
setting: the number of components of a program is fixed and the
attacker can only get to compromise some of them. Hence he cannot
mount arbitrary attacks. We need a variant of full abstraction more
tailored to our setting if we want to make sure that there are no
false attacks.

We want to restrict the number of components of the low-level attacker
to fit our setting. Then, we want to find an appropriate property
∆(P,Q,n) such that it holds that
   ∀PQn, ∆(P,Q,n) ↔ (∀a, |a| = n → a⋈P↓ ~L a⋈Q↓)
which means that we can characterize low-level attacks using ∆(P,Q,n).

We try two variants:
  * ∆(P,Q,n) = (∀A, |A| = n → A⋈P ~H A⋈Q) ;
  * ∆(P,Q,n) = (∀A, A⋈P ~H A⋈Q).

Full abstraction variant 1
--------------------------

FA': ∀PQn, (∀A, |A| = n → A⋈P  ~H A⋈Q )
         ↔ (∀a, |a| = n → a⋈P↓ ~L a⋈Q↓).


Full abstraction variant 2
--------------------------

FA'': ∀PQn, (∀A, A⋈P  ~H A⋈Q )
          ↔ (∀a, |a| = n → a⋈P↓ ~L a⋈Q↓).


Lemma: FA' → FA.
----------------

Assume FA'. Let's prove FA.
Let P Q.
→: Assume H: (∀A, A⋈P ~H A⋈Q ).
   Let a. We must show that a⋈P↓ ~L a⋈Q↓.
   Instantiate FA' with P=P, Q=Q, n=|a|.
   The left hand side
     (∀A, |A| = |a| → A⋈P ~H A⋈Q)
   follows from H.
   Hence we get
     (∀a', |a'| = |a| → a'⋈P↓ ~L a'⋈Q↓)
   which we can instantiate with a to get
     a⋈P↓ ~L a⋈Q↓.

←: Assume H: (∀a, a⋈P↓ ~L a⋈Q↓).
   Let A. We must show that A⋈P ~H A⋈Q.
   Instantiate FA' with P=P, Q=Q, n=|A|.
   The right hand side
     (∀a, |a| = |A| → a⋈P↓ ~L a⋈Q↓)
   follows from H.
   Hence we get
     (∀A', |A'| = |A| → A'⋈P ~H A'⋈Q)
   which we can instantiate with A to get
     A⋈P ~H A⋈Q.

Lemma: FA ↛ FA'.
----------------

To show this we must find a setting in which FA is true, yet FA' is
not.

Assume we have full abstraction and two programs P and Q that can be
distinguished using only one component in the high-level, yet cannot
be distinguished using only one component in the low-level (say, for
example, that they can be distinguished using two components). Then,
FA' is false because we have found P=P Q=Q and n = 1 such that
  (∀a, |a| = 1 → a⋈P↓ ~L a⋈Q↓)
is true and yet
  (∀A, |A| = 1 → A⋈P  ~H A⋈Q )
is false.

